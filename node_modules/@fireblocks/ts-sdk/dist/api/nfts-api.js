"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateOwnershipTokensBlockchainDescriptorEnum = exports.ListOwnedTokensSpamEnum = exports.ListOwnedTokensStatusEnum = exports.ListOwnedTokensOrderEnum = exports.ListOwnedTokensSortEnum = exports.ListOwnedTokensWalletTypeEnum = exports.ListOwnedCollectionsStatusEnum = exports.ListOwnedCollectionsOrderEnum = exports.ListOwnedCollectionsSortEnum = exports.ListOwnedCollectionsWalletTypeEnum = exports.GetOwnershipTokensSpamEnum = exports.GetOwnershipTokensStatusEnum = exports.GetOwnershipTokensOrderEnum = exports.GetOwnershipTokensSortEnum = exports.GetOwnershipTokensWalletTypeEnum = exports.GetOwnershipTokensBlockchainDescriptorEnum = exports.GetNFTsOrderEnum = exports.GetNFTsSortEnum = exports.NFTsApi = exports.NFTsApiFactory = exports.NFTsApiFp = exports.NFTsApiAxiosParamCreator = void 0;
var axios_1 = __importDefault(require("axios"));
var fireblocksResponse_1 = require("../response/fireblocksResponse");
// URLSearchParams not necessarily used
// @ts-ignore
var url_1 = require("url");
// Some imports not used depending on template conditions
// @ts-ignore
var common_1 = require("../common");
var validation_utils_1 = require("../utils/validation_utils");
// @ts-ignore
var base_1 = require("../base");
/**
 * NFTsApi - axios parameter creator
 * @export
 */
var NFTsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Returns the requested token data.
         * @summary List token data by ID
         * @param {string} id NFT ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFT: function (id, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getNFT', 'id', id);
                    localVarPath = "/nfts/tokens/{id}"
                        .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns the requested tokens data.
         * @summary List tokens by IDs
         * @param {string} ids A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<GetNFTsSortEnum>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {GetNFTsOrderEnum} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFTs: function (ids, pageCursor, pageSize, sort, order, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getNFTs', 'ids', ids);
                    localVarPath = "/nfts/tokens";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (ids !== undefined) {
                        localVarQueryParameter['ids'] = ids;
                    }
                    if (pageCursor !== undefined) {
                        localVarQueryParameter['pageCursor'] = pageCursor;
                    }
                    if (pageSize !== undefined) {
                        localVarQueryParameter['pageSize'] = pageSize;
                    }
                    if (sort) {
                        localVarQueryParameter['sort'] = sort;
                    }
                    if (order !== undefined) {
                        localVarQueryParameter['order'] = order;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns all tokens and their data in your workspace.
         * @summary List all owned tokens (paginated)
         * @param {GetOwnershipTokensBlockchainDescriptorEnum} [blockchainDescriptor] Blockchain descriptor filter
         * @param {string} [vaultAccountIds] A comma separated list of Vault Account IDs. Up to 100 are allowed in a single request.  This field will be ignored when walletType&#x3D;END_USER_WALLET or ncwId is provided.
         * @param {string} [ncwId] Tenant\&#39;s Non-Custodial Wallet ID
         * @param {string} [ncwAccountIds] A comma separated list of Non-Custodial account IDs. Up to 100 are allowed in a single request. This field will be ignored when walletType&#x3D;VAULT_ACCOUNT or ncwId is not provided.
         * @param {GetOwnershipTokensWalletTypeEnum} [walletType] Wallet type, it can be &#x60;VAULT_ACCOUNT&#x60; or &#x60;END_USER_WALLET&#x60;
         * @param {string} [ids] A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
         * @param {string} [collectionIds] A comma separated list of collection IDs. Up to 100 are allowed in a single request.
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<GetOwnershipTokensSortEnum>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {GetOwnershipTokensOrderEnum} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {GetOwnershipTokensStatusEnum} [status] Token ownership status
         * @param {string} [search] Search owned tokens and their collections. Possible criteria for search:  token name and id within the contract/collection, collection name, blockchain descriptor and name.
         * @param {GetOwnershipTokensSpamEnum} [spam] Token ownership spam status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnershipTokens: function (blockchainDescriptor, vaultAccountIds, ncwId, ncwAccountIds, walletType, ids, collectionIds, pageCursor, pageSize, sort, order, status, search, spam, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/nfts/ownership/tokens";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (blockchainDescriptor !== undefined) {
                        localVarQueryParameter['blockchainDescriptor'] = blockchainDescriptor;
                    }
                    if (vaultAccountIds !== undefined) {
                        localVarQueryParameter['vaultAccountIds'] = vaultAccountIds;
                    }
                    if (ncwId !== undefined) {
                        localVarQueryParameter['ncwId'] = ncwId;
                    }
                    if (ncwAccountIds !== undefined) {
                        localVarQueryParameter['ncwAccountIds'] = ncwAccountIds;
                    }
                    if (walletType !== undefined) {
                        localVarQueryParameter['walletType'] = walletType;
                    }
                    if (ids !== undefined) {
                        localVarQueryParameter['ids'] = ids;
                    }
                    if (collectionIds !== undefined) {
                        localVarQueryParameter['collectionIds'] = collectionIds;
                    }
                    if (pageCursor !== undefined) {
                        localVarQueryParameter['pageCursor'] = pageCursor;
                    }
                    if (pageSize !== undefined) {
                        localVarQueryParameter['pageSize'] = pageSize;
                    }
                    if (sort) {
                        localVarQueryParameter['sort'] = sort;
                    }
                    if (order !== undefined) {
                        localVarQueryParameter['order'] = order;
                    }
                    if (status !== undefined) {
                        localVarQueryParameter['status'] = status;
                    }
                    if (search !== undefined) {
                        localVarQueryParameter['search'] = search;
                    }
                    if (spam !== undefined) {
                        localVarQueryParameter['spam'] = spam;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns all collections in your workspace
         * @summary List owned collections (paginated)
         * @param {string} [ncwId] Tenant\&#39;s Non-Custodial Wallet ID
         * @param {ListOwnedCollectionsWalletTypeEnum} [walletType] Wallet type, it can be &#x60;VAULT_ACCOUNT&#x60; or &#x60;END_USER_WALLET&#x60;
         * @param {string} [search] Search owned collections. Possible criteria for search: collection name, collection contract address.
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<ListOwnedCollectionsSortEnum>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {ListOwnedCollectionsOrderEnum} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {ListOwnedCollectionsStatusEnum} [status] Token ownership status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnedCollections: function (ncwId, walletType, search, pageCursor, pageSize, sort, order, status, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/nfts/ownership/collections";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (ncwId !== undefined) {
                        localVarQueryParameter['ncwId'] = ncwId;
                    }
                    if (walletType !== undefined) {
                        localVarQueryParameter['walletType'] = walletType;
                    }
                    if (search !== undefined) {
                        localVarQueryParameter['search'] = search;
                    }
                    if (pageCursor !== undefined) {
                        localVarQueryParameter['pageCursor'] = pageCursor;
                    }
                    if (pageSize !== undefined) {
                        localVarQueryParameter['pageSize'] = pageSize;
                    }
                    if (sort) {
                        localVarQueryParameter['sort'] = sort;
                    }
                    if (order !== undefined) {
                        localVarQueryParameter['order'] = order;
                    }
                    if (status !== undefined) {
                        localVarQueryParameter['status'] = status;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns all owned distinct tokens (for your tenant) and their data in your workspace.
         * @summary List all distinct owned tokens (paginated)
         * @param {string} [ncwId] Tenant\&#39;s Non-Custodial Wallet ID
         * @param {ListOwnedTokensWalletTypeEnum} [walletType] Wallet type, it can be &#x60;VAULT_ACCOUNT&#x60; or &#x60;END_USER_WALLET&#x60;
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<ListOwnedTokensSortEnum>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {ListOwnedTokensOrderEnum} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {ListOwnedTokensStatusEnum} [status] Token ownership status
         * @param {string} [search] Search owned tokens by token name
         * @param {ListOwnedTokensSpamEnum} [spam] Token ownership spam status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnedTokens: function (ncwId, walletType, pageCursor, pageSize, sort, order, status, search, spam, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/nfts/ownership/assets";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (ncwId !== undefined) {
                        localVarQueryParameter['ncwId'] = ncwId;
                    }
                    if (walletType !== undefined) {
                        localVarQueryParameter['walletType'] = walletType;
                    }
                    if (pageCursor !== undefined) {
                        localVarQueryParameter['pageCursor'] = pageCursor;
                    }
                    if (pageSize !== undefined) {
                        localVarQueryParameter['pageSize'] = pageSize;
                    }
                    if (sort) {
                        localVarQueryParameter['sort'] = sort;
                    }
                    if (order !== undefined) {
                        localVarQueryParameter['order'] = order;
                    }
                    if (status !== undefined) {
                        localVarQueryParameter['status'] = status;
                    }
                    if (search !== undefined) {
                        localVarQueryParameter['search'] = search;
                    }
                    if (spam !== undefined) {
                        localVarQueryParameter['spam'] = spam;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Updates the latest token metadata.
         * @summary Refresh token metadata
         * @param {string} id NFT ID
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshNFTMetadata: function (id, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('refreshNFTMetadata', 'id', id);
                    localVarPath = "/nfts/tokens/{id}"
                        .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Updates all tokens and balances per blockchain and vault account.
         * @summary Refresh vault account tokens
         * @param {UpdateOwnershipTokensBlockchainDescriptorEnum} blockchainDescriptor Blockchain descriptor filter
         * @param {string} vaultAccountId Vault account filter
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOwnershipTokens: function (blockchainDescriptor, vaultAccountId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('updateOwnershipTokens', 'blockchainDescriptor', blockchainDescriptor);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('updateOwnershipTokens', 'vaultAccountId', vaultAccountId);
                    localVarPath = "/nfts/ownership/tokens";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (blockchainDescriptor !== undefined) {
                        localVarQueryParameter['blockchainDescriptor'] = blockchainDescriptor;
                    }
                    if (vaultAccountId !== undefined) {
                        localVarQueryParameter['vaultAccountId'] = vaultAccountId;
                    }
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Updates token status for a tenant, in all tenant vaults.
         * @summary Update token ownership status
         * @param {UpdateTokenOwnershipStatusDto} updateTokenOwnershipStatusDto
         * @param {string} id NFT ID
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTokenOwnershipStatus: function (updateTokenOwnershipStatusDto, id, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('updateTokenOwnershipStatus', 'updateTokenOwnershipStatusDto', updateTokenOwnershipStatusDto);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('updateTokenOwnershipStatus', 'id', id);
                    localVarPath = "/nfts/ownership/tokens/{id}/status"
                        .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateTokenOwnershipStatusDto, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Updates tokens spam property for a tenant\'s token ownerships, in all tenant vaults.
         * @summary Update tokens ownership spam property
         * @param {UpdateTokensOwnershipSpamRequest} updateTokensOwnershipSpamRequest
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTokensOwnershipSpam: function (updateTokensOwnershipSpamRequest, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('updateTokensOwnershipSpam', 'updateTokensOwnershipSpamRequest', updateTokensOwnershipSpamRequest);
                    localVarPath = "/nfts/ownership/tokens/spam";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateTokensOwnershipSpamRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Updates tokens status for a tenant, in all tenant vaults.
         * @summary Update tokens ownership status
         * @param {UpdateTokensOwnershipStatusRequest} updateTokensOwnershipStatusRequest
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTokensOwnershipStatus: function (updateTokensOwnershipStatusRequest, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('updateTokensOwnershipStatus', 'updateTokensOwnershipStatusRequest', updateTokensOwnershipStatusRequest);
                    localVarPath = "/nfts/ownership/tokens/status";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateTokensOwnershipStatusRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.NFTsApiAxiosParamCreator = NFTsApiAxiosParamCreator;
/**
 * NFTsApi - functional programming interface
 * @export
 */
var NFTsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.NFTsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns the requested token data.
         * @summary List token data by ID
         * @param {string} id NFT ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFT: function (id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNFT(id, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['NFTsApi.getNFT']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Returns the requested tokens data.
         * @summary List tokens by IDs
         * @param {string} ids A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<GetNFTsSortEnum>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {GetNFTsOrderEnum} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFTs: function (ids, pageCursor, pageSize, sort, order, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getNFTs(ids, pageCursor, pageSize, sort, order, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['NFTsApi.getNFTs']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Returns all tokens and their data in your workspace.
         * @summary List all owned tokens (paginated)
         * @param {GetOwnershipTokensBlockchainDescriptorEnum} [blockchainDescriptor] Blockchain descriptor filter
         * @param {string} [vaultAccountIds] A comma separated list of Vault Account IDs. Up to 100 are allowed in a single request.  This field will be ignored when walletType&#x3D;END_USER_WALLET or ncwId is provided.
         * @param {string} [ncwId] Tenant\&#39;s Non-Custodial Wallet ID
         * @param {string} [ncwAccountIds] A comma separated list of Non-Custodial account IDs. Up to 100 are allowed in a single request. This field will be ignored when walletType&#x3D;VAULT_ACCOUNT or ncwId is not provided.
         * @param {GetOwnershipTokensWalletTypeEnum} [walletType] Wallet type, it can be &#x60;VAULT_ACCOUNT&#x60; or &#x60;END_USER_WALLET&#x60;
         * @param {string} [ids] A comma separated list of NFT IDs. Up to 100 are allowed in a single request.
         * @param {string} [collectionIds] A comma separated list of collection IDs. Up to 100 are allowed in a single request.
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<GetOwnershipTokensSortEnum>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {GetOwnershipTokensOrderEnum} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {GetOwnershipTokensStatusEnum} [status] Token ownership status
         * @param {string} [search] Search owned tokens and their collections. Possible criteria for search:  token name and id within the contract/collection, collection name, blockchain descriptor and name.
         * @param {GetOwnershipTokensSpamEnum} [spam] Token ownership spam status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnershipTokens: function (blockchainDescriptor, vaultAccountIds, ncwId, ncwAccountIds, walletType, ids, collectionIds, pageCursor, pageSize, sort, order, status, search, spam, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getOwnershipTokens(blockchainDescriptor, vaultAccountIds, ncwId, ncwAccountIds, walletType, ids, collectionIds, pageCursor, pageSize, sort, order, status, search, spam, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['NFTsApi.getOwnershipTokens']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Returns all collections in your workspace
         * @summary List owned collections (paginated)
         * @param {string} [ncwId] Tenant\&#39;s Non-Custodial Wallet ID
         * @param {ListOwnedCollectionsWalletTypeEnum} [walletType] Wallet type, it can be &#x60;VAULT_ACCOUNT&#x60; or &#x60;END_USER_WALLET&#x60;
         * @param {string} [search] Search owned collections. Possible criteria for search: collection name, collection contract address.
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<ListOwnedCollectionsSortEnum>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {ListOwnedCollectionsOrderEnum} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {ListOwnedCollectionsStatusEnum} [status] Token ownership status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnedCollections: function (ncwId, walletType, search, pageCursor, pageSize, sort, order, status, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listOwnedCollections(ncwId, walletType, search, pageCursor, pageSize, sort, order, status, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['NFTsApi.listOwnedCollections']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Returns all owned distinct tokens (for your tenant) and their data in your workspace.
         * @summary List all distinct owned tokens (paginated)
         * @param {string} [ncwId] Tenant\&#39;s Non-Custodial Wallet ID
         * @param {ListOwnedTokensWalletTypeEnum} [walletType] Wallet type, it can be &#x60;VAULT_ACCOUNT&#x60; or &#x60;END_USER_WALLET&#x60;
         * @param {string} [pageCursor] Page cursor to fetch
         * @param {number} [pageSize] Items per page (max 100)
         * @param {Array<ListOwnedTokensSortEnum>} [sort] Sort by param, it can be one param or a list of params separated by comma
         * @param {ListOwnedTokensOrderEnum} [order] Order direction, it can be &#x60;ASC&#x60; for ascending or &#x60;DESC&#x60; for descending
         * @param {ListOwnedTokensStatusEnum} [status] Token ownership status
         * @param {string} [search] Search owned tokens by token name
         * @param {ListOwnedTokensSpamEnum} [spam] Token ownership spam status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnedTokens: function (ncwId, walletType, pageCursor, pageSize, sort, order, status, search, spam, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.listOwnedTokens(ncwId, walletType, pageCursor, pageSize, sort, order, status, search, spam, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['NFTsApi.listOwnedTokens']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Updates the latest token metadata.
         * @summary Refresh token metadata
         * @param {string} id NFT ID
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshNFTMetadata: function (id, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.refreshNFTMetadata(id, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['NFTsApi.refreshNFTMetadata']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Updates all tokens and balances per blockchain and vault account.
         * @summary Refresh vault account tokens
         * @param {UpdateOwnershipTokensBlockchainDescriptorEnum} blockchainDescriptor Blockchain descriptor filter
         * @param {string} vaultAccountId Vault account filter
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOwnershipTokens: function (blockchainDescriptor, vaultAccountId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateOwnershipTokens(blockchainDescriptor, vaultAccountId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['NFTsApi.updateOwnershipTokens']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Updates token status for a tenant, in all tenant vaults.
         * @summary Update token ownership status
         * @param {UpdateTokenOwnershipStatusDto} updateTokenOwnershipStatusDto
         * @param {string} id NFT ID
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTokenOwnershipStatus: function (updateTokenOwnershipStatusDto, id, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateTokenOwnershipStatus(updateTokenOwnershipStatusDto, id, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['NFTsApi.updateTokenOwnershipStatus']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Updates tokens spam property for a tenant\'s token ownerships, in all tenant vaults.
         * @summary Update tokens ownership spam property
         * @param {UpdateTokensOwnershipSpamRequest} updateTokensOwnershipSpamRequest
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTokensOwnershipSpam: function (updateTokensOwnershipSpamRequest, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateTokensOwnershipSpam(updateTokensOwnershipSpamRequest, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['NFTsApi.updateTokensOwnershipSpam']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Updates tokens status for a tenant, in all tenant vaults.
         * @summary Update tokens ownership status
         * @param {UpdateTokensOwnershipStatusRequest} updateTokensOwnershipStatusRequest
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTokensOwnershipStatus: function (updateTokensOwnershipStatusRequest, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateTokensOwnershipStatus(updateTokensOwnershipStatusRequest, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['NFTsApi.updateTokensOwnershipStatus']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
    };
};
exports.NFTsApiFp = NFTsApiFp;
/**
 * NFTsApi - factory interface
 * @export
 */
var NFTsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.NFTsApiFp)(configuration);
    return {
        /**
         * Returns the requested token data.
         * @summary List token data by ID
         * @param {NFTsApiGetNFTRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFT: function (requestParameters, options) {
            return localVarFp.getNFT(requestParameters.id, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns the requested tokens data.
         * @summary List tokens by IDs
         * @param {NFTsApiGetNFTsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNFTs: function (requestParameters, options) {
            return localVarFp.getNFTs(requestParameters.ids, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns all tokens and their data in your workspace.
         * @summary List all owned tokens (paginated)
         * @param {NFTsApiGetOwnershipTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnershipTokens: function (requestParameters, options) {
            if (requestParameters === void 0) { requestParameters = {}; }
            return localVarFp.getOwnershipTokens(requestParameters.blockchainDescriptor, requestParameters.vaultAccountIds, requestParameters.ncwId, requestParameters.ncwAccountIds, requestParameters.walletType, requestParameters.ids, requestParameters.collectionIds, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.status, requestParameters.search, requestParameters.spam, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns all collections in your workspace
         * @summary List owned collections (paginated)
         * @param {NFTsApiListOwnedCollectionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnedCollections: function (requestParameters, options) {
            if (requestParameters === void 0) { requestParameters = {}; }
            return localVarFp.listOwnedCollections(requestParameters.ncwId, requestParameters.walletType, requestParameters.search, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.status, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns all owned distinct tokens (for your tenant) and their data in your workspace.
         * @summary List all distinct owned tokens (paginated)
         * @param {NFTsApiListOwnedTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOwnedTokens: function (requestParameters, options) {
            if (requestParameters === void 0) { requestParameters = {}; }
            return localVarFp.listOwnedTokens(requestParameters.ncwId, requestParameters.walletType, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.status, requestParameters.search, requestParameters.spam, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Updates the latest token metadata.
         * @summary Refresh token metadata
         * @param {NFTsApiRefreshNFTMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshNFTMetadata: function (requestParameters, options) {
            return localVarFp.refreshNFTMetadata(requestParameters.id, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Updates all tokens and balances per blockchain and vault account.
         * @summary Refresh vault account tokens
         * @param {NFTsApiUpdateOwnershipTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOwnershipTokens: function (requestParameters, options) {
            return localVarFp.updateOwnershipTokens(requestParameters.blockchainDescriptor, requestParameters.vaultAccountId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Updates token status for a tenant, in all tenant vaults.
         * @summary Update token ownership status
         * @param {NFTsApiUpdateTokenOwnershipStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTokenOwnershipStatus: function (requestParameters, options) {
            return localVarFp.updateTokenOwnershipStatus(requestParameters.updateTokenOwnershipStatusDto, requestParameters.id, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Updates tokens spam property for a tenant\'s token ownerships, in all tenant vaults.
         * @summary Update tokens ownership spam property
         * @param {NFTsApiUpdateTokensOwnershipSpamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTokensOwnershipSpam: function (requestParameters, options) {
            return localVarFp.updateTokensOwnershipSpam(requestParameters.updateTokensOwnershipSpamRequest, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Updates tokens status for a tenant, in all tenant vaults.
         * @summary Update tokens ownership status
         * @param {NFTsApiUpdateTokensOwnershipStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTokensOwnershipStatus: function (requestParameters, options) {
            return localVarFp.updateTokensOwnershipStatus(requestParameters.updateTokensOwnershipStatusRequest, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.NFTsApiFactory = NFTsApiFactory;
/**
 * NFTsApi - object-oriented interface
 * @export
 * @class NFTsApi
 * @extends {BaseAPI}
 */
var NFTsApi = /** @class */ (function (_super) {
    __extends(NFTsApi, _super);
    function NFTsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the requested token data.
     * @summary List token data by ID
     * @param {NFTsApiGetNFTRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    NFTsApi.prototype.getNFT = function (requestParameters) {
        var _this = this;
        return (0, exports.NFTsApiFp)(this.configuration).getNFT(requestParameters.id).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Returns the requested tokens data.
     * @summary List tokens by IDs
     * @param {NFTsApiGetNFTsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    NFTsApi.prototype.getNFTs = function (requestParameters) {
        var _this = this;
        return (0, exports.NFTsApiFp)(this.configuration).getNFTs(requestParameters.ids, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Returns all tokens and their data in your workspace.
     * @summary List all owned tokens (paginated)
     * @param {NFTsApiGetOwnershipTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    NFTsApi.prototype.getOwnershipTokens = function (requestParameters) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.NFTsApiFp)(this.configuration).getOwnershipTokens(requestParameters.blockchainDescriptor, requestParameters.vaultAccountIds, requestParameters.ncwId, requestParameters.ncwAccountIds, requestParameters.walletType, requestParameters.ids, requestParameters.collectionIds, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.status, requestParameters.search, requestParameters.spam).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Returns all collections in your workspace
     * @summary List owned collections (paginated)
     * @param {NFTsApiListOwnedCollectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    NFTsApi.prototype.listOwnedCollections = function (requestParameters) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.NFTsApiFp)(this.configuration).listOwnedCollections(requestParameters.ncwId, requestParameters.walletType, requestParameters.search, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.status).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Returns all owned distinct tokens (for your tenant) and their data in your workspace.
     * @summary List all distinct owned tokens (paginated)
     * @param {NFTsApiListOwnedTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    NFTsApi.prototype.listOwnedTokens = function (requestParameters) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.NFTsApiFp)(this.configuration).listOwnedTokens(requestParameters.ncwId, requestParameters.walletType, requestParameters.pageCursor, requestParameters.pageSize, requestParameters.sort, requestParameters.order, requestParameters.status, requestParameters.search, requestParameters.spam).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Updates the latest token metadata.
     * @summary Refresh token metadata
     * @param {NFTsApiRefreshNFTMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    NFTsApi.prototype.refreshNFTMetadata = function (requestParameters) {
        var _this = this;
        return (0, exports.NFTsApiFp)(this.configuration).refreshNFTMetadata(requestParameters.id, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Updates all tokens and balances per blockchain and vault account.
     * @summary Refresh vault account tokens
     * @param {NFTsApiUpdateOwnershipTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    NFTsApi.prototype.updateOwnershipTokens = function (requestParameters) {
        var _this = this;
        return (0, exports.NFTsApiFp)(this.configuration).updateOwnershipTokens(requestParameters.blockchainDescriptor, requestParameters.vaultAccountId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Updates token status for a tenant, in all tenant vaults.
     * @summary Update token ownership status
     * @param {NFTsApiUpdateTokenOwnershipStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    NFTsApi.prototype.updateTokenOwnershipStatus = function (requestParameters) {
        var _this = this;
        return (0, exports.NFTsApiFp)(this.configuration).updateTokenOwnershipStatus(requestParameters.updateTokenOwnershipStatusDto, requestParameters.id, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Updates tokens spam property for a tenant\'s token ownerships, in all tenant vaults.
     * @summary Update tokens ownership spam property
     * @param {NFTsApiUpdateTokensOwnershipSpamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    NFTsApi.prototype.updateTokensOwnershipSpam = function (requestParameters) {
        var _this = this;
        return (0, exports.NFTsApiFp)(this.configuration).updateTokensOwnershipSpam(requestParameters.updateTokensOwnershipSpamRequest, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Updates tokens status for a tenant, in all tenant vaults.
     * @summary Update tokens ownership status
     * @param {NFTsApiUpdateTokensOwnershipStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NFTsApi
     */
    NFTsApi.prototype.updateTokensOwnershipStatus = function (requestParameters) {
        var _this = this;
        return (0, exports.NFTsApiFp)(this.configuration).updateTokensOwnershipStatus(requestParameters.updateTokensOwnershipStatusRequest, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    return NFTsApi;
}(base_1.BaseAPI));
exports.NFTsApi = NFTsApi;
/**
 * @export
 */
exports.GetNFTsSortEnum = {
    CollectionName: 'collection.name',
    Name: 'name',
    BlockchainDescriptor: 'blockchainDescriptor'
};
/**
 * @export
 */
exports.GetNFTsOrderEnum = {
    Desc: 'DESC',
    Asc: 'ASC'
};
/**
 * @export
 */
exports.GetOwnershipTokensBlockchainDescriptorEnum = {
    Eth: 'ETH',
    EthTest3: 'ETH_TEST3',
    EthTest5: 'ETH_TEST5',
    EthTest6: 'ETH_TEST6',
    Polygon: 'POLYGON',
    PolygonTestMumbai: 'POLYGON_TEST_MUMBAI',
    AmoyPolygonTest: 'AMOY_POLYGON_TEST',
    Xtz: 'XTZ',
    XtzTest: 'XTZ_TEST',
    BasechainEth: 'BASECHAIN_ETH',
    BasechainEthTest3: 'BASECHAIN_ETH_TEST3',
    Etherlink: 'ETHERLINK',
    EtherlinkTest: 'ETHERLINK_TEST',
    Mantle: 'MANTLE',
    MantleTest: 'MANTLE_TEST',
    GunGunzillaTest: 'GUN_GUNZILLA_TEST'
};
/**
 * @export
 */
exports.GetOwnershipTokensWalletTypeEnum = {
    VaultAccount: 'VAULT_ACCOUNT',
    EndUserWallet: 'END_USER_WALLET'
};
/**
 * @export
 */
exports.GetOwnershipTokensSortEnum = {
    OwnershipLastUpdateTime: 'ownershipLastUpdateTime',
    Name: 'name',
    CollectionName: 'collection.name',
    BlockchainDescriptor: 'blockchainDescriptor'
};
/**
 * @export
 */
exports.GetOwnershipTokensOrderEnum = {
    Desc: 'DESC',
    Asc: 'ASC'
};
/**
 * @export
 */
exports.GetOwnershipTokensStatusEnum = {
    Listed: 'LISTED',
    Archived: 'ARCHIVED'
};
/**
 * @export
 */
exports.GetOwnershipTokensSpamEnum = {
    True: 'true',
    False: 'false',
    All: 'all'
};
/**
 * @export
 */
exports.ListOwnedCollectionsWalletTypeEnum = {
    VaultAccount: 'VAULT_ACCOUNT',
    EndUserWallet: 'END_USER_WALLET'
};
/**
 * @export
 */
exports.ListOwnedCollectionsSortEnum = {
    Name: 'name'
};
/**
 * @export
 */
exports.ListOwnedCollectionsOrderEnum = {
    Desc: 'DESC',
    Asc: 'ASC'
};
/**
 * @export
 */
exports.ListOwnedCollectionsStatusEnum = {
    Listed: 'LISTED',
    Archived: 'ARCHIVED'
};
/**
 * @export
 */
exports.ListOwnedTokensWalletTypeEnum = {
    VaultAccount: 'VAULT_ACCOUNT',
    EndUserWallet: 'END_USER_WALLET'
};
/**
 * @export
 */
exports.ListOwnedTokensSortEnum = {
    Name: 'name'
};
/**
 * @export
 */
exports.ListOwnedTokensOrderEnum = {
    Desc: 'DESC',
    Asc: 'ASC'
};
/**
 * @export
 */
exports.ListOwnedTokensStatusEnum = {
    Listed: 'LISTED',
    Archived: 'ARCHIVED'
};
/**
 * @export
 */
exports.ListOwnedTokensSpamEnum = {
    True: 'true',
    False: 'false',
    All: 'all'
};
/**
 * @export
 */
exports.UpdateOwnershipTokensBlockchainDescriptorEnum = {
    Eth: 'ETH',
    EthTest5: 'ETH_TEST5',
    EthTest6: 'ETH_TEST6',
    Polygon: 'POLYGON',
    PolygonTestMumbai: 'POLYGON_TEST_MUMBAI',
    AmoyPolygonTest: 'AMOY_POLYGON_TEST',
    BasechainEth: 'BASECHAIN_ETH',
    Etherlink: 'ETHERLINK',
    EtherlinkTest: 'ETHERLINK_TEST',
    Mantle: 'MANTLE',
    MantleTest: 'MANTLE_TEST',
    GunGunzillaTest: 'GUN_GUNZILLA_TEST'
};
//# sourceMappingURL=nfts-api.js.map
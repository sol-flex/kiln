"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetPagedVaultAccountsOrderByEnum = exports.GetAssetWalletsOrderByEnum = exports.VaultsApi = exports.VaultsApiFactory = exports.VaultsApiFp = exports.VaultsApiAxiosParamCreator = void 0;
var axios_1 = __importDefault(require("axios"));
var fireblocksResponse_1 = require("../response/fireblocksResponse");
// URLSearchParams not necessarily used
// @ts-ignore
var url_1 = require("url");
// Some imports not used depending on template conditions
// @ts-ignore
var common_1 = require("../common");
var validation_utils_1 = require("../utils/validation_utils");
// @ts-ignore
var base_1 = require("../base");
/**
 * VaultsApi - axios parameter creator
 * @export
 */
var VaultsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Initiates activation for a wallet in a vault account.
         * @summary Activate a wallet in a vault account
         * @param {string} vaultAccountId The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
         * @param {string} assetId The ID of the asset
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAssetForVaultAccount: function (vaultAccountId, assetId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('activateAssetForVaultAccount', 'vaultAccountId', vaultAccountId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('activateAssetForVaultAccount', 'assetId', assetId);
                    localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/activate"
                        .replace("{".concat("vaultAccountId", "}"), encodeURIComponent(String(vaultAccountId)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Converts an existing segwit address to the legacy format.
         * @summary Convert a segwit address to legacy format
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {string} addressId The segwit address to translate
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLegacyAddress: function (vaultAccountId, assetId, addressId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('createLegacyAddress', 'vaultAccountId', vaultAccountId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('createLegacyAddress', 'assetId', assetId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('createLegacyAddress', 'addressId', addressId);
                    localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/create_legacy"
                        .replace("{".concat("vaultAccountId", "}"), encodeURIComponent(String(vaultAccountId)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)))
                        .replace("{".concat("addressId", "}"), encodeURIComponent(String(addressId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Create multiple vault accounts by running an async job. </br> **Note**: - These endpoints are currently in beta and might be subject to changes. - We limit accounts to 10k per operation and 200k per customer during beta testing.
         * @summary Bulk creation of new vault accounts
         * @param {CreateMultipleAccountsRequest} createMultipleAccountsRequest
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMultipleAccounts: function (createMultipleAccountsRequest, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('createMultipleAccounts', 'createMultipleAccountsRequest', createMultipleAccountsRequest);
                    localVarPath = "/vault/accounts/bulk";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createMultipleAccountsRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Creates a new vault account with the requested name.
         * @summary Create a new vault account
         * @param {CreateVaultAccountRequest} createVaultAccountRequest
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVaultAccount: function (createVaultAccountRequest, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('createVaultAccount', 'createVaultAccountRequest', createVaultAccountRequest);
                    localVarPath = "/vault/accounts";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createVaultAccountRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Creates a wallet for a specific asset in a vault account.
         * @summary Create a new wallet
         * @param {string} vaultAccountId The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
         * @param {string} assetId The ID of the asset
         * @param {CreateAssetsRequest} [createAssetsRequest]
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVaultAccountAsset: function (vaultAccountId, assetId, createAssetsRequest, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('createVaultAccountAsset', 'vaultAccountId', vaultAccountId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('createVaultAccountAsset', 'assetId', assetId);
                    localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}"
                        .replace("{".concat("vaultAccountId", "}"), encodeURIComponent(String(vaultAccountId)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createAssetsRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Creates a new deposit address for an asset of a vault account.
         * @summary Create new asset deposit address
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {CreateAddressRequest} [createAddressRequest]
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVaultAccountAssetAddress: function (vaultAccountId, assetId, createAddressRequest, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('createVaultAccountAssetAddress', 'vaultAccountId', vaultAccountId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('createVaultAccountAssetAddress', 'assetId', assetId);
                    localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/addresses"
                        .replace("{".concat("vaultAccountId", "}"), encodeURIComponent(String(vaultAccountId)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createAddressRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Gets all asset wallets at all of the vault accounts in your workspace. An asset wallet is an asset at a vault account. This method allows fast traversal of all account balances.
         * @summary List asset wallets (Paginated)
         * @param {number} [totalAmountLargerThan] When specified, only asset wallets with total balance larger than this amount are returned.
         * @param {string} [assetId] When specified, only asset wallets cross vault accounts that have this asset ID are returned.
         * @param {GetAssetWalletsOrderByEnum} [orderBy]
         * @param {string} [before] Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page.
         * @param {string} [after] Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page.
         * @param {number} [limit] The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetWallets: function (totalAmountLargerThan, assetId, orderBy, before, after, limit, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/vault/asset_wallets";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (totalAmountLargerThan !== undefined) {
                        localVarQueryParameter['totalAmountLargerThan'] = totalAmountLargerThan;
                    }
                    if (assetId !== undefined) {
                        localVarQueryParameter['assetId'] = assetId;
                    }
                    if (orderBy !== undefined) {
                        localVarQueryParameter['orderBy'] = orderBy;
                    }
                    if (before !== undefined) {
                        localVarQueryParameter['before'] = before;
                    }
                    if (after !== undefined) {
                        localVarQueryParameter['after'] = after;
                    }
                    if (limit !== undefined) {
                        localVarQueryParameter['limit'] = limit;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get the maximum amount of a particular asset that can be spent in a single transaction from a specified vault account (UTXO assets only, with a limitation on number of inputs embedded). Send several transactions if you want to spend more than the maximum spendable amount.
         * @summary Get the maximum spendable amount in a single transaction.
         * @param {string} vaultAccountId The ID of the vault account, or \&#39;default\&#39; for the default vault account
         * @param {string} assetId The ID of the asset
         * @param {boolean} [manualSignging] False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxSpendableAmount: function (vaultAccountId, assetId, manualSignging, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getMaxSpendableAmount', 'vaultAccountId', vaultAccountId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getMaxSpendableAmount', 'assetId', assetId);
                    localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/max_spendable_amount"
                        .replace("{".concat("vaultAccountId", "}"), encodeURIComponent(String(vaultAccountId)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (manualSignging !== undefined) {
                        localVarQueryParameter['manualSignging'] = manualSignging;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Gets all vault accounts in your workspace. This endpoint returns a limited amount of results with a quick response time.
         * @summary List vault accounts (Paginated)
         * @param {string} [namePrefix]
         * @param {string} [nameSuffix]
         * @param {number} [minAmountThreshold] Specifying minAmountThreshold will filter accounts with balances greater than this value, otherwise, it will return all accounts.
         * @param {string} [assetId]
         * @param {GetPagedVaultAccountsOrderByEnum} [orderBy]
         * @param {string} [before]
         * @param {string} [after]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPagedVaultAccounts: function (namePrefix, nameSuffix, minAmountThreshold, assetId, orderBy, before, after, limit, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/vault/accounts_paged";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (namePrefix !== undefined) {
                        localVarQueryParameter['namePrefix'] = namePrefix;
                    }
                    if (nameSuffix !== undefined) {
                        localVarQueryParameter['nameSuffix'] = nameSuffix;
                    }
                    if (minAmountThreshold !== undefined) {
                        localVarQueryParameter['minAmountThreshold'] = minAmountThreshold;
                    }
                    if (assetId !== undefined) {
                        localVarQueryParameter['assetId'] = assetId;
                    }
                    if (orderBy !== undefined) {
                        localVarQueryParameter['orderBy'] = orderBy;
                    }
                    if (before !== undefined) {
                        localVarQueryParameter['before'] = before;
                    }
                    if (after !== undefined) {
                        localVarQueryParameter['after'] = after;
                    }
                    if (limit !== undefined) {
                        localVarQueryParameter['limit'] = limit;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Gets the public key information based on derivation path and signing algorithm.
         * @summary Get the public key information
         * @param {string} derivationPath
         * @param {string} algorithm
         * @param {boolean} [compressed]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyInfo: function (derivationPath, algorithm, compressed, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getPublicKeyInfo', 'derivationPath', derivationPath);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getPublicKeyInfo', 'algorithm', algorithm);
                    localVarPath = "/vault/public_key_info";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (derivationPath !== undefined) {
                        localVarQueryParameter['derivationPath'] = derivationPath;
                    }
                    if (algorithm !== undefined) {
                        localVarQueryParameter['algorithm'] = algorithm;
                    }
                    if (compressed !== undefined) {
                        localVarQueryParameter['compressed'] = compressed;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Gets the public key information for the vault account.
         * @summary Get the public key for a vault account
         * @param {string} vaultAccountId
         * @param {string} assetId
         * @param {number} change
         * @param {number} addressIndex
         * @param {boolean} [compressed]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyInfoForAddress: function (vaultAccountId, assetId, change, addressIndex, compressed, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getPublicKeyInfoForAddress', 'vaultAccountId', vaultAccountId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getPublicKeyInfoForAddress', 'assetId', assetId);
                    (0, common_1.assertParamExists)('getPublicKeyInfoForAddress', 'change', change);
                    (0, common_1.assertParamExists)('getPublicKeyInfoForAddress', 'addressIndex', addressIndex);
                    localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/{change}/{addressIndex}/public_key_info"
                        .replace("{".concat("vaultAccountId", "}"), encodeURIComponent(String(vaultAccountId)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)))
                        .replace("{".concat("change", "}"), encodeURIComponent(String(change)))
                        .replace("{".concat("addressIndex", "}"), encodeURIComponent(String(addressIndex)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (compressed !== undefined) {
                        localVarQueryParameter['compressed'] = compressed;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns unspent inputs information of an asset in a vault account.
         * @summary Get UTXO unspent inputs information
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnspentInputs: function (vaultAccountId, assetId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getUnspentInputs', 'vaultAccountId', vaultAccountId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getUnspentInputs', 'assetId', assetId);
                    localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/unspent_inputs"
                        .replace("{".concat("vaultAccountId", "}"), encodeURIComponent(String(vaultAccountId)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns the requested vault account.
         * @summary Find a vault account by ID
         * @param {string} vaultAccountId The ID of the vault account to return type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccount: function (vaultAccountId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getVaultAccount', 'vaultAccountId', vaultAccountId);
                    localVarPath = "/vault/accounts/{vaultAccountId}"
                        .replace("{".concat("vaultAccountId", "}"), encodeURIComponent(String(vaultAccountId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a wallet for a specific asset of a vault account.
         * @summary Get the asset balance for a vault account
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccountAsset: function (vaultAccountId, assetId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getVaultAccountAsset', 'vaultAccountId', vaultAccountId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getVaultAccountAsset', 'assetId', assetId);
                    localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}"
                        .replace("{".concat("vaultAccountId", "}"), encodeURIComponent(String(vaultAccountId)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Returns a paginated response of the addresses for a given vault account and asset.
         * @summary List addresses (Paginated)
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {number} [limit]
         * @param {string} [before]
         * @param {string} [after]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccountAssetAddressesPaginated: function (vaultAccountId, assetId, limit, before, after, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getVaultAccountAssetAddressesPaginated', 'vaultAccountId', vaultAccountId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getVaultAccountAssetAddressesPaginated', 'assetId', assetId);
                    localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/addresses_paginated"
                        .replace("{".concat("vaultAccountId", "}"), encodeURIComponent(String(vaultAccountId)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (limit !== undefined) {
                        localVarQueryParameter['limit'] = limit;
                    }
                    if (before !== undefined) {
                        localVarQueryParameter['before'] = before;
                    }
                    if (after !== undefined) {
                        localVarQueryParameter['after'] = after;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Gets the assets amount summary for all accounts or filtered accounts.
         * @summary Get asset balance for chosen assets
         * @param {string} [accountNamePrefix]
         * @param {string} [accountNameSuffix]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAssets: function (accountNamePrefix, accountNameSuffix, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/vault/assets";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (accountNamePrefix !== undefined) {
                        localVarQueryParameter['accountNamePrefix'] = accountNamePrefix;
                    }
                    if (accountNameSuffix !== undefined) {
                        localVarQueryParameter['accountNameSuffix'] = accountNameSuffix;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Gets the vault balance summary for an asset.
         * @summary Get vault balance by asset
         * @param {string} assetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultBalanceByAsset: function (assetId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getVaultBalanceByAsset', 'assetId', assetId);
                    localVarPath = "/vault/assets/{assetId}"
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Hides the requested vault account from the web console view.
         * @summary Hide a vault account in the console
         * @param {string} vaultAccountId The vault account to hide
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideVaultAccount: function (vaultAccountId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('hideVaultAccount', 'vaultAccountId', vaultAccountId);
                    localVarPath = "/vault/accounts/{vaultAccountId}/hide"
                        .replace("{".concat("vaultAccountId", "}"), encodeURIComponent(String(vaultAccountId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Sets an AML/KYT customer reference ID for a specific address.
         * @summary Assign AML customer reference ID
         * @param {SetCustomerRefIdForAddressRequest} setCustomerRefIdForAddressRequest
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {string} addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomerRefIdForAddress: function (setCustomerRefIdForAddressRequest, vaultAccountId, assetId, addressId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('setCustomerRefIdForAddress', 'setCustomerRefIdForAddressRequest', setCustomerRefIdForAddressRequest);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('setCustomerRefIdForAddress', 'vaultAccountId', vaultAccountId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('setCustomerRefIdForAddress', 'assetId', assetId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('setCustomerRefIdForAddress', 'addressId', addressId);
                    localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/set_customer_ref_id"
                        .replace("{".concat("vaultAccountId", "}"), encodeURIComponent(String(vaultAccountId)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)))
                        .replace("{".concat("addressId", "}"), encodeURIComponent(String(addressId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(setCustomerRefIdForAddressRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Sets the autofueling property of the vault account to enabled or disabled.
         * @summary Turn autofueling on or off
         * @param {SetAutoFuelRequest} setAutoFuelRequest
         * @param {string} vaultAccountId The vault account ID
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setVaultAccountAutoFuel: function (setAutoFuelRequest, vaultAccountId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('setVaultAccountAutoFuel', 'setAutoFuelRequest', setAutoFuelRequest);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('setVaultAccountAutoFuel', 'vaultAccountId', vaultAccountId);
                    localVarPath = "/vault/accounts/{vaultAccountId}/set_auto_fuel"
                        .replace("{".concat("vaultAccountId", "}"), encodeURIComponent(String(vaultAccountId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(setAutoFuelRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Assigns an AML/KYT customer reference ID for the vault account.
         * @summary Set an AML/KYT customer reference ID for a vault account
         * @param {SetCustomerRefIdRequest} setCustomerRefIdRequest
         * @param {string} vaultAccountId The vault account ID
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setVaultAccountCustomerRefId: function (setCustomerRefIdRequest, vaultAccountId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('setVaultAccountCustomerRefId', 'setCustomerRefIdRequest', setCustomerRefIdRequest);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('setVaultAccountCustomerRefId', 'vaultAccountId', vaultAccountId);
                    localVarPath = "/vault/accounts/{vaultAccountId}/set_customer_ref_id"
                        .replace("{".concat("vaultAccountId", "}"), encodeURIComponent(String(vaultAccountId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(setCustomerRefIdRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Makes a hidden vault account visible in web console view.
         * @summary Unhide a vault account in the console
         * @param {string} vaultAccountId The vault account to unhide
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unhideVaultAccount: function (vaultAccountId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('unhideVaultAccount', 'vaultAccountId', vaultAccountId);
                    localVarPath = "/vault/accounts/{vaultAccountId}/unhide"
                        .replace("{".concat("vaultAccountId", "}"), encodeURIComponent(String(vaultAccountId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Renames the requested vault account.
         * @summary Rename a vault account
         * @param {UpdateVaultAccountRequest} updateVaultAccountRequest
         * @param {string} vaultAccountId The ID of the vault account to edit
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVaultAccount: function (updateVaultAccountRequest, vaultAccountId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('updateVaultAccount', 'updateVaultAccountRequest', updateVaultAccountRequest);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('updateVaultAccount', 'vaultAccountId', vaultAccountId);
                    localVarPath = "/vault/accounts/{vaultAccountId}"
                        .replace("{".concat("vaultAccountId", "}"), encodeURIComponent(String(vaultAccountId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateVaultAccountRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Updates the description of an existing address of an asset in a vault account.
         * @summary Update address description
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {string} addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
         * @param {UpdateVaultAccountAssetAddressRequest} [updateVaultAccountAssetAddressRequest]
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVaultAccountAssetAddress: function (vaultAccountId, assetId, addressId, updateVaultAccountAssetAddressRequest, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('updateVaultAccountAssetAddress', 'vaultAccountId', vaultAccountId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('updateVaultAccountAssetAddress', 'assetId', assetId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('updateVaultAccountAssetAddress', 'addressId', addressId);
                    localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}"
                        .replace("{".concat("vaultAccountId", "}"), encodeURIComponent(String(vaultAccountId)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)))
                        .replace("{".concat("addressId", "}"), encodeURIComponent(String(addressId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateVaultAccountAssetAddressRequest, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Updates the balance of a specific asset in a vault account.
         * @summary Refresh asset balance data
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVaultAccountAssetBalance: function (vaultAccountId, assetId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('updateVaultAccountAssetBalance', 'vaultAccountId', vaultAccountId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('updateVaultAccountAssetBalance', 'assetId', assetId);
                    localVarPath = "/vault/accounts/{vaultAccountId}/{assetId}/balance"
                        .replace("{".concat("vaultAccountId", "}"), encodeURIComponent(String(vaultAccountId)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.VaultsApiAxiosParamCreator = VaultsApiAxiosParamCreator;
/**
 * VaultsApi - functional programming interface
 * @export
 */
var VaultsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.VaultsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Initiates activation for a wallet in a vault account.
         * @summary Activate a wallet in a vault account
         * @param {string} vaultAccountId The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
         * @param {string} assetId The ID of the asset
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAssetForVaultAccount: function (vaultAccountId, assetId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.activateAssetForVaultAccount(vaultAccountId, assetId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.activateAssetForVaultAccount']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Converts an existing segwit address to the legacy format.
         * @summary Convert a segwit address to legacy format
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {string} addressId The segwit address to translate
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLegacyAddress: function (vaultAccountId, assetId, addressId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createLegacyAddress(vaultAccountId, assetId, addressId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.createLegacyAddress']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Create multiple vault accounts by running an async job. </br> **Note**: - These endpoints are currently in beta and might be subject to changes. - We limit accounts to 10k per operation and 200k per customer during beta testing.
         * @summary Bulk creation of new vault accounts
         * @param {CreateMultipleAccountsRequest} createMultipleAccountsRequest
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMultipleAccounts: function (createMultipleAccountsRequest, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createMultipleAccounts(createMultipleAccountsRequest, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.createMultipleAccounts']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Creates a new vault account with the requested name.
         * @summary Create a new vault account
         * @param {CreateVaultAccountRequest} createVaultAccountRequest
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVaultAccount: function (createVaultAccountRequest, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createVaultAccount(createVaultAccountRequest, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.createVaultAccount']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Creates a wallet for a specific asset in a vault account.
         * @summary Create a new wallet
         * @param {string} vaultAccountId The ID of the vault account to return, or \&#39;default\&#39; for the default vault account
         * @param {string} assetId The ID of the asset
         * @param {CreateAssetsRequest} [createAssetsRequest]
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVaultAccountAsset: function (vaultAccountId, assetId, createAssetsRequest, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createVaultAccountAsset(vaultAccountId, assetId, createAssetsRequest, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.createVaultAccountAsset']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Creates a new deposit address for an asset of a vault account.
         * @summary Create new asset deposit address
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {CreateAddressRequest} [createAddressRequest]
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVaultAccountAssetAddress: function (vaultAccountId, assetId, createAddressRequest, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createVaultAccountAssetAddress(vaultAccountId, assetId, createAddressRequest, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.createVaultAccountAssetAddress']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Gets all asset wallets at all of the vault accounts in your workspace. An asset wallet is an asset at a vault account. This method allows fast traversal of all account balances.
         * @summary List asset wallets (Paginated)
         * @param {number} [totalAmountLargerThan] When specified, only asset wallets with total balance larger than this amount are returned.
         * @param {string} [assetId] When specified, only asset wallets cross vault accounts that have this asset ID are returned.
         * @param {GetAssetWalletsOrderByEnum} [orderBy]
         * @param {string} [before] Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page.
         * @param {string} [after] Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page.
         * @param {number} [limit] The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetWallets: function (totalAmountLargerThan, assetId, orderBy, before, after, limit, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getAssetWallets(totalAmountLargerThan, assetId, orderBy, before, after, limit, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.getAssetWallets']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Get the maximum amount of a particular asset that can be spent in a single transaction from a specified vault account (UTXO assets only, with a limitation on number of inputs embedded). Send several transactions if you want to spend more than the maximum spendable amount.
         * @summary Get the maximum spendable amount in a single transaction.
         * @param {string} vaultAccountId The ID of the vault account, or \&#39;default\&#39; for the default vault account
         * @param {string} assetId The ID of the asset
         * @param {boolean} [manualSignging] False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxSpendableAmount: function (vaultAccountId, assetId, manualSignging, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getMaxSpendableAmount(vaultAccountId, assetId, manualSignging, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.getMaxSpendableAmount']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Gets all vault accounts in your workspace. This endpoint returns a limited amount of results with a quick response time.
         * @summary List vault accounts (Paginated)
         * @param {string} [namePrefix]
         * @param {string} [nameSuffix]
         * @param {number} [minAmountThreshold] Specifying minAmountThreshold will filter accounts with balances greater than this value, otherwise, it will return all accounts.
         * @param {string} [assetId]
         * @param {GetPagedVaultAccountsOrderByEnum} [orderBy]
         * @param {string} [before]
         * @param {string} [after]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPagedVaultAccounts: function (namePrefix, nameSuffix, minAmountThreshold, assetId, orderBy, before, after, limit, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPagedVaultAccounts(namePrefix, nameSuffix, minAmountThreshold, assetId, orderBy, before, after, limit, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.getPagedVaultAccounts']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Gets the public key information based on derivation path and signing algorithm.
         * @summary Get the public key information
         * @param {string} derivationPath
         * @param {string} algorithm
         * @param {boolean} [compressed]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyInfo: function (derivationPath, algorithm, compressed, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPublicKeyInfo(derivationPath, algorithm, compressed, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.getPublicKeyInfo']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Gets the public key information for the vault account.
         * @summary Get the public key for a vault account
         * @param {string} vaultAccountId
         * @param {string} assetId
         * @param {number} change
         * @param {number} addressIndex
         * @param {boolean} [compressed]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyInfoForAddress: function (vaultAccountId, assetId, change, addressIndex, compressed, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getPublicKeyInfoForAddress(vaultAccountId, assetId, change, addressIndex, compressed, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.getPublicKeyInfoForAddress']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Returns unspent inputs information of an asset in a vault account.
         * @summary Get UTXO unspent inputs information
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnspentInputs: function (vaultAccountId, assetId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getUnspentInputs(vaultAccountId, assetId, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.getUnspentInputs']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Returns the requested vault account.
         * @summary Find a vault account by ID
         * @param {string} vaultAccountId The ID of the vault account to return type: string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccount: function (vaultAccountId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getVaultAccount(vaultAccountId, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.getVaultAccount']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Returns a wallet for a specific asset of a vault account.
         * @summary Get the asset balance for a vault account
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccountAsset: function (vaultAccountId, assetId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getVaultAccountAsset(vaultAccountId, assetId, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.getVaultAccountAsset']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Returns a paginated response of the addresses for a given vault account and asset.
         * @summary List addresses (Paginated)
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {number} [limit]
         * @param {string} [before]
         * @param {string} [after]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccountAssetAddressesPaginated: function (vaultAccountId, assetId, limit, before, after, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getVaultAccountAssetAddressesPaginated(vaultAccountId, assetId, limit, before, after, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.getVaultAccountAssetAddressesPaginated']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Gets the assets amount summary for all accounts or filtered accounts.
         * @summary Get asset balance for chosen assets
         * @param {string} [accountNamePrefix]
         * @param {string} [accountNameSuffix]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAssets: function (accountNamePrefix, accountNameSuffix, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getVaultAssets(accountNamePrefix, accountNameSuffix, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.getVaultAssets']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Gets the vault balance summary for an asset.
         * @summary Get vault balance by asset
         * @param {string} assetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultBalanceByAsset: function (assetId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getVaultBalanceByAsset(assetId, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.getVaultBalanceByAsset']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Hides the requested vault account from the web console view.
         * @summary Hide a vault account in the console
         * @param {string} vaultAccountId The vault account to hide
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideVaultAccount: function (vaultAccountId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.hideVaultAccount(vaultAccountId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.hideVaultAccount']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Sets an AML/KYT customer reference ID for a specific address.
         * @summary Assign AML customer reference ID
         * @param {SetCustomerRefIdForAddressRequest} setCustomerRefIdForAddressRequest
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {string} addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomerRefIdForAddress: function (setCustomerRefIdForAddressRequest, vaultAccountId, assetId, addressId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setCustomerRefIdForAddress(setCustomerRefIdForAddressRequest, vaultAccountId, assetId, addressId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.setCustomerRefIdForAddress']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Sets the autofueling property of the vault account to enabled or disabled.
         * @summary Turn autofueling on or off
         * @param {SetAutoFuelRequest} setAutoFuelRequest
         * @param {string} vaultAccountId The vault account ID
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setVaultAccountAutoFuel: function (setAutoFuelRequest, vaultAccountId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setVaultAccountAutoFuel(setAutoFuelRequest, vaultAccountId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.setVaultAccountAutoFuel']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Assigns an AML/KYT customer reference ID for the vault account.
         * @summary Set an AML/KYT customer reference ID for a vault account
         * @param {SetCustomerRefIdRequest} setCustomerRefIdRequest
         * @param {string} vaultAccountId The vault account ID
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setVaultAccountCustomerRefId: function (setCustomerRefIdRequest, vaultAccountId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setVaultAccountCustomerRefId(setCustomerRefIdRequest, vaultAccountId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.setVaultAccountCustomerRefId']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Makes a hidden vault account visible in web console view.
         * @summary Unhide a vault account in the console
         * @param {string} vaultAccountId The vault account to unhide
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unhideVaultAccount: function (vaultAccountId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unhideVaultAccount(vaultAccountId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.unhideVaultAccount']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Renames the requested vault account.
         * @summary Rename a vault account
         * @param {UpdateVaultAccountRequest} updateVaultAccountRequest
         * @param {string} vaultAccountId The ID of the vault account to edit
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVaultAccount: function (updateVaultAccountRequest, vaultAccountId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateVaultAccount(updateVaultAccountRequest, vaultAccountId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.updateVaultAccount']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Updates the description of an existing address of an asset in a vault account.
         * @summary Update address description
         * @param {string} vaultAccountId The ID of the vault account
         * @param {string} assetId The ID of the asset
         * @param {string} addressId The address for which to add a description. For XRP, use &lt;address&gt;:&lt;tag&gt;, for all other assets, use only the address
         * @param {UpdateVaultAccountAssetAddressRequest} [updateVaultAccountAssetAddressRequest]
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVaultAccountAssetAddress: function (vaultAccountId, assetId, addressId, updateVaultAccountAssetAddressRequest, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateVaultAccountAssetAddress(vaultAccountId, assetId, addressId, updateVaultAccountAssetAddressRequest, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.updateVaultAccountAssetAddress']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Updates the balance of a specific asset in a vault account.
         * @summary Refresh asset balance data
         * @param {string} vaultAccountId The ID of the vault account to return
         * @param {string} assetId The ID of the asset
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVaultAccountAssetBalance: function (vaultAccountId, assetId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateVaultAccountAssetBalance(vaultAccountId, assetId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['VaultsApi.updateVaultAccountAssetBalance']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
    };
};
exports.VaultsApiFp = VaultsApiFp;
/**
 * VaultsApi - factory interface
 * @export
 */
var VaultsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.VaultsApiFp)(configuration);
    return {
        /**
         * Initiates activation for a wallet in a vault account.
         * @summary Activate a wallet in a vault account
         * @param {VaultsApiActivateAssetForVaultAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAssetForVaultAccount: function (requestParameters, options) {
            return localVarFp.activateAssetForVaultAccount(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Converts an existing segwit address to the legacy format.
         * @summary Convert a segwit address to legacy format
         * @param {VaultsApiCreateLegacyAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLegacyAddress: function (requestParameters, options) {
            return localVarFp.createLegacyAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.addressId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Create multiple vault accounts by running an async job. </br> **Note**: - These endpoints are currently in beta and might be subject to changes. - We limit accounts to 10k per operation and 200k per customer during beta testing.
         * @summary Bulk creation of new vault accounts
         * @param {VaultsApiCreateMultipleAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMultipleAccounts: function (requestParameters, options) {
            return localVarFp.createMultipleAccounts(requestParameters.createMultipleAccountsRequest, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Creates a new vault account with the requested name.
         * @summary Create a new vault account
         * @param {VaultsApiCreateVaultAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVaultAccount: function (requestParameters, options) {
            return localVarFp.createVaultAccount(requestParameters.createVaultAccountRequest, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Creates a wallet for a specific asset in a vault account.
         * @summary Create a new wallet
         * @param {VaultsApiCreateVaultAccountAssetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVaultAccountAsset: function (requestParameters, options) {
            return localVarFp.createVaultAccountAsset(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.createAssetsRequest, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Creates a new deposit address for an asset of a vault account.
         * @summary Create new asset deposit address
         * @param {VaultsApiCreateVaultAccountAssetAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVaultAccountAssetAddress: function (requestParameters, options) {
            return localVarFp.createVaultAccountAssetAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.createAddressRequest, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Gets all asset wallets at all of the vault accounts in your workspace. An asset wallet is an asset at a vault account. This method allows fast traversal of all account balances.
         * @summary List asset wallets (Paginated)
         * @param {VaultsApiGetAssetWalletsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetWallets: function (requestParameters, options) {
            if (requestParameters === void 0) { requestParameters = {}; }
            return localVarFp.getAssetWallets(requestParameters.totalAmountLargerThan, requestParameters.assetId, requestParameters.orderBy, requestParameters.before, requestParameters.after, requestParameters.limit, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get the maximum amount of a particular asset that can be spent in a single transaction from a specified vault account (UTXO assets only, with a limitation on number of inputs embedded). Send several transactions if you want to spend more than the maximum spendable amount.
         * @summary Get the maximum spendable amount in a single transaction.
         * @param {VaultsApiGetMaxSpendableAmountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxSpendableAmount: function (requestParameters, options) {
            return localVarFp.getMaxSpendableAmount(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.manualSignging, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Gets all vault accounts in your workspace. This endpoint returns a limited amount of results with a quick response time.
         * @summary List vault accounts (Paginated)
         * @param {VaultsApiGetPagedVaultAccountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPagedVaultAccounts: function (requestParameters, options) {
            if (requestParameters === void 0) { requestParameters = {}; }
            return localVarFp.getPagedVaultAccounts(requestParameters.namePrefix, requestParameters.nameSuffix, requestParameters.minAmountThreshold, requestParameters.assetId, requestParameters.orderBy, requestParameters.before, requestParameters.after, requestParameters.limit, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Gets the public key information based on derivation path and signing algorithm.
         * @summary Get the public key information
         * @param {VaultsApiGetPublicKeyInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyInfo: function (requestParameters, options) {
            return localVarFp.getPublicKeyInfo(requestParameters.derivationPath, requestParameters.algorithm, requestParameters.compressed, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Gets the public key information for the vault account.
         * @summary Get the public key for a vault account
         * @param {VaultsApiGetPublicKeyInfoForAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKeyInfoForAddress: function (requestParameters, options) {
            return localVarFp.getPublicKeyInfoForAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.change, requestParameters.addressIndex, requestParameters.compressed, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns unspent inputs information of an asset in a vault account.
         * @summary Get UTXO unspent inputs information
         * @param {VaultsApiGetUnspentInputsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnspentInputs: function (requestParameters, options) {
            return localVarFp.getUnspentInputs(requestParameters.vaultAccountId, requestParameters.assetId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns the requested vault account.
         * @summary Find a vault account by ID
         * @param {VaultsApiGetVaultAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccount: function (requestParameters, options) {
            return localVarFp.getVaultAccount(requestParameters.vaultAccountId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a wallet for a specific asset of a vault account.
         * @summary Get the asset balance for a vault account
         * @param {VaultsApiGetVaultAccountAssetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccountAsset: function (requestParameters, options) {
            return localVarFp.getVaultAccountAsset(requestParameters.vaultAccountId, requestParameters.assetId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Returns a paginated response of the addresses for a given vault account and asset.
         * @summary List addresses (Paginated)
         * @param {VaultsApiGetVaultAccountAssetAddressesPaginatedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAccountAssetAddressesPaginated: function (requestParameters, options) {
            return localVarFp.getVaultAccountAssetAddressesPaginated(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.limit, requestParameters.before, requestParameters.after, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Gets the assets amount summary for all accounts or filtered accounts.
         * @summary Get asset balance for chosen assets
         * @param {VaultsApiGetVaultAssetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultAssets: function (requestParameters, options) {
            if (requestParameters === void 0) { requestParameters = {}; }
            return localVarFp.getVaultAssets(requestParameters.accountNamePrefix, requestParameters.accountNameSuffix, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Gets the vault balance summary for an asset.
         * @summary Get vault balance by asset
         * @param {VaultsApiGetVaultBalanceByAssetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultBalanceByAsset: function (requestParameters, options) {
            return localVarFp.getVaultBalanceByAsset(requestParameters.assetId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Hides the requested vault account from the web console view.
         * @summary Hide a vault account in the console
         * @param {VaultsApiHideVaultAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideVaultAccount: function (requestParameters, options) {
            return localVarFp.hideVaultAccount(requestParameters.vaultAccountId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Sets an AML/KYT customer reference ID for a specific address.
         * @summary Assign AML customer reference ID
         * @param {VaultsApiSetCustomerRefIdForAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCustomerRefIdForAddress: function (requestParameters, options) {
            return localVarFp.setCustomerRefIdForAddress(requestParameters.setCustomerRefIdForAddressRequest, requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.addressId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Sets the autofueling property of the vault account to enabled or disabled.
         * @summary Turn autofueling on or off
         * @param {VaultsApiSetVaultAccountAutoFuelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setVaultAccountAutoFuel: function (requestParameters, options) {
            return localVarFp.setVaultAccountAutoFuel(requestParameters.setAutoFuelRequest, requestParameters.vaultAccountId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Assigns an AML/KYT customer reference ID for the vault account.
         * @summary Set an AML/KYT customer reference ID for a vault account
         * @param {VaultsApiSetVaultAccountCustomerRefIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setVaultAccountCustomerRefId: function (requestParameters, options) {
            return localVarFp.setVaultAccountCustomerRefId(requestParameters.setCustomerRefIdRequest, requestParameters.vaultAccountId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Makes a hidden vault account visible in web console view.
         * @summary Unhide a vault account in the console
         * @param {VaultsApiUnhideVaultAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unhideVaultAccount: function (requestParameters, options) {
            return localVarFp.unhideVaultAccount(requestParameters.vaultAccountId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Renames the requested vault account.
         * @summary Rename a vault account
         * @param {VaultsApiUpdateVaultAccountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVaultAccount: function (requestParameters, options) {
            return localVarFp.updateVaultAccount(requestParameters.updateVaultAccountRequest, requestParameters.vaultAccountId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Updates the description of an existing address of an asset in a vault account.
         * @summary Update address description
         * @param {VaultsApiUpdateVaultAccountAssetAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVaultAccountAssetAddress: function (requestParameters, options) {
            return localVarFp.updateVaultAccountAssetAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.addressId, requestParameters.updateVaultAccountAssetAddressRequest, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Updates the balance of a specific asset in a vault account.
         * @summary Refresh asset balance data
         * @param {VaultsApiUpdateVaultAccountAssetBalanceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVaultAccountAssetBalance: function (requestParameters, options) {
            return localVarFp.updateVaultAccountAssetBalance(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.VaultsApiFactory = VaultsApiFactory;
/**
 * VaultsApi - object-oriented interface
 * @export
 * @class VaultsApi
 * @extends {BaseAPI}
 */
var VaultsApi = /** @class */ (function (_super) {
    __extends(VaultsApi, _super);
    function VaultsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Initiates activation for a wallet in a vault account.
     * @summary Activate a wallet in a vault account
     * @param {VaultsApiActivateAssetForVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.activateAssetForVaultAccount = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).activateAssetForVaultAccount(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Converts an existing segwit address to the legacy format.
     * @summary Convert a segwit address to legacy format
     * @param {VaultsApiCreateLegacyAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.createLegacyAddress = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).createLegacyAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.addressId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Create multiple vault accounts by running an async job. </br> **Note**: - These endpoints are currently in beta and might be subject to changes. - We limit accounts to 10k per operation and 200k per customer during beta testing.
     * @summary Bulk creation of new vault accounts
     * @param {VaultsApiCreateMultipleAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.createMultipleAccounts = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).createMultipleAccounts(requestParameters.createMultipleAccountsRequest, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Creates a new vault account with the requested name.
     * @summary Create a new vault account
     * @param {VaultsApiCreateVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.createVaultAccount = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).createVaultAccount(requestParameters.createVaultAccountRequest, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Creates a wallet for a specific asset in a vault account.
     * @summary Create a new wallet
     * @param {VaultsApiCreateVaultAccountAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.createVaultAccountAsset = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).createVaultAccountAsset(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.createAssetsRequest, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Creates a new deposit address for an asset of a vault account.
     * @summary Create new asset deposit address
     * @param {VaultsApiCreateVaultAccountAssetAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.createVaultAccountAssetAddress = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).createVaultAccountAssetAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.createAddressRequest, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Gets all asset wallets at all of the vault accounts in your workspace. An asset wallet is an asset at a vault account. This method allows fast traversal of all account balances.
     * @summary List asset wallets (Paginated)
     * @param {VaultsApiGetAssetWalletsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.getAssetWallets = function (requestParameters) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.VaultsApiFp)(this.configuration).getAssetWallets(requestParameters.totalAmountLargerThan, requestParameters.assetId, requestParameters.orderBy, requestParameters.before, requestParameters.after, requestParameters.limit).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Get the maximum amount of a particular asset that can be spent in a single transaction from a specified vault account (UTXO assets only, with a limitation on number of inputs embedded). Send several transactions if you want to spend more than the maximum spendable amount.
     * @summary Get the maximum spendable amount in a single transaction.
     * @param {VaultsApiGetMaxSpendableAmountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.getMaxSpendableAmount = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).getMaxSpendableAmount(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.manualSignging).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Gets all vault accounts in your workspace. This endpoint returns a limited amount of results with a quick response time.
     * @summary List vault accounts (Paginated)
     * @param {VaultsApiGetPagedVaultAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.getPagedVaultAccounts = function (requestParameters) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.VaultsApiFp)(this.configuration).getPagedVaultAccounts(requestParameters.namePrefix, requestParameters.nameSuffix, requestParameters.minAmountThreshold, requestParameters.assetId, requestParameters.orderBy, requestParameters.before, requestParameters.after, requestParameters.limit).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Gets the public key information based on derivation path and signing algorithm.
     * @summary Get the public key information
     * @param {VaultsApiGetPublicKeyInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.getPublicKeyInfo = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).getPublicKeyInfo(requestParameters.derivationPath, requestParameters.algorithm, requestParameters.compressed).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Gets the public key information for the vault account.
     * @summary Get the public key for a vault account
     * @param {VaultsApiGetPublicKeyInfoForAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.getPublicKeyInfoForAddress = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).getPublicKeyInfoForAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.change, requestParameters.addressIndex, requestParameters.compressed).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Returns unspent inputs information of an asset in a vault account.
     * @summary Get UTXO unspent inputs information
     * @param {VaultsApiGetUnspentInputsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.getUnspentInputs = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).getUnspentInputs(requestParameters.vaultAccountId, requestParameters.assetId).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Returns the requested vault account.
     * @summary Find a vault account by ID
     * @param {VaultsApiGetVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.getVaultAccount = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).getVaultAccount(requestParameters.vaultAccountId).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Returns a wallet for a specific asset of a vault account.
     * @summary Get the asset balance for a vault account
     * @param {VaultsApiGetVaultAccountAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.getVaultAccountAsset = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).getVaultAccountAsset(requestParameters.vaultAccountId, requestParameters.assetId).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Returns a paginated response of the addresses for a given vault account and asset.
     * @summary List addresses (Paginated)
     * @param {VaultsApiGetVaultAccountAssetAddressesPaginatedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.getVaultAccountAssetAddressesPaginated = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).getVaultAccountAssetAddressesPaginated(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.limit, requestParameters.before, requestParameters.after).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Gets the assets amount summary for all accounts or filtered accounts.
     * @summary Get asset balance for chosen assets
     * @param {VaultsApiGetVaultAssetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.getVaultAssets = function (requestParameters) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.VaultsApiFp)(this.configuration).getVaultAssets(requestParameters.accountNamePrefix, requestParameters.accountNameSuffix).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Gets the vault balance summary for an asset.
     * @summary Get vault balance by asset
     * @param {VaultsApiGetVaultBalanceByAssetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.getVaultBalanceByAsset = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).getVaultBalanceByAsset(requestParameters.assetId).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Hides the requested vault account from the web console view.
     * @summary Hide a vault account in the console
     * @param {VaultsApiHideVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.hideVaultAccount = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).hideVaultAccount(requestParameters.vaultAccountId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Sets an AML/KYT customer reference ID for a specific address.
     * @summary Assign AML customer reference ID
     * @param {VaultsApiSetCustomerRefIdForAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.setCustomerRefIdForAddress = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).setCustomerRefIdForAddress(requestParameters.setCustomerRefIdForAddressRequest, requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.addressId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Sets the autofueling property of the vault account to enabled or disabled.
     * @summary Turn autofueling on or off
     * @param {VaultsApiSetVaultAccountAutoFuelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.setVaultAccountAutoFuel = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).setVaultAccountAutoFuel(requestParameters.setAutoFuelRequest, requestParameters.vaultAccountId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Assigns an AML/KYT customer reference ID for the vault account.
     * @summary Set an AML/KYT customer reference ID for a vault account
     * @param {VaultsApiSetVaultAccountCustomerRefIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.setVaultAccountCustomerRefId = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).setVaultAccountCustomerRefId(requestParameters.setCustomerRefIdRequest, requestParameters.vaultAccountId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Makes a hidden vault account visible in web console view.
     * @summary Unhide a vault account in the console
     * @param {VaultsApiUnhideVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.unhideVaultAccount = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).unhideVaultAccount(requestParameters.vaultAccountId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Renames the requested vault account.
     * @summary Rename a vault account
     * @param {VaultsApiUpdateVaultAccountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.updateVaultAccount = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).updateVaultAccount(requestParameters.updateVaultAccountRequest, requestParameters.vaultAccountId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Updates the description of an existing address of an asset in a vault account.
     * @summary Update address description
     * @param {VaultsApiUpdateVaultAccountAssetAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.updateVaultAccountAssetAddress = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).updateVaultAccountAssetAddress(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.addressId, requestParameters.updateVaultAccountAssetAddressRequest, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Updates the balance of a specific asset in a vault account.
     * @summary Refresh asset balance data
     * @param {VaultsApiUpdateVaultAccountAssetBalanceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VaultsApi
     */
    VaultsApi.prototype.updateVaultAccountAssetBalance = function (requestParameters) {
        var _this = this;
        return (0, exports.VaultsApiFp)(this.configuration).updateVaultAccountAssetBalance(requestParameters.vaultAccountId, requestParameters.assetId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    return VaultsApi;
}(base_1.BaseAPI));
exports.VaultsApi = VaultsApi;
/**
 * @export
 */
exports.GetAssetWalletsOrderByEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
};
/**
 * @export
 */
exports.GetPagedVaultAccountsOrderByEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
};
//# sourceMappingURL=vaults-api.js.map
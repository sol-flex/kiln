"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchTicketsTypeEnum = exports.SearchTicketsStatusesEnum = exports.SmartTransferApi = exports.SmartTransferApiFactory = exports.SmartTransferApiFp = exports.SmartTransferApiAxiosParamCreator = void 0;
var axios_1 = __importDefault(require("axios"));
var fireblocksResponse_1 = require("../response/fireblocksResponse");
// URLSearchParams not necessarily used
// @ts-ignore
var url_1 = require("url");
// Some imports not used depending on template conditions
// @ts-ignore
var common_1 = require("../common");
var validation_utils_1 = require("../utils/validation_utils");
// @ts-ignore
var base_1 = require("../base");
/**
 * SmartTransferApi - axios parameter creator
 * @export
 */
var SmartTransferApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Set funding source for ticket term and creating approving transaction for contract to transfer asset
         * @summary Define funding source and give approve to contract to transfer asset
         * @param {SmartTransferApproveTerm} smartTransferApproveTerm
         * @param {string} ticketId
         * @param {string} termId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveDvPTicketTerm: function (smartTransferApproveTerm, ticketId, termId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('approveDvPTicketTerm', 'smartTransferApproveTerm', smartTransferApproveTerm);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('approveDvPTicketTerm', 'ticketId', ticketId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('approveDvPTicketTerm', 'termId', termId);
                    localVarPath = "/smart_transfers/{ticketId}/terms/{termId}/dvp/approve"
                        .replace("{".concat("ticketId", "}"), encodeURIComponent(String(ticketId)))
                        .replace("{".concat("termId", "}"), encodeURIComponent(String(termId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(smartTransferApproveTerm, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Cancel Smart Transfer ticket
         * @summary Cancel Ticket
         * @param {string} ticketId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTicket: function (ticketId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('cancelTicket', 'ticketId', ticketId);
                    localVarPath = "/smart-transfers/{ticketId}/cancel"
                        .replace("{".concat("ticketId", "}"), encodeURIComponent(String(ticketId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Creates new Smart Transfer ticket
         * @summary Create Ticket
         * @param {SmartTransferCreateTicket} smartTransferCreateTicket
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket: function (smartTransferCreateTicket, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('createTicket', 'smartTransferCreateTicket', smartTransferCreateTicket);
                    localVarPath = "/smart-transfers";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(smartTransferCreateTicket, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Creates new smart transfer ticket term (when the ticket status is DRAFT)
         * @summary Create leg (term)
         * @param {SmartTransferCreateTicketTerm} smartTransferCreateTicketTerm
         * @param {string} ticketId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketTerm: function (smartTransferCreateTicketTerm, ticketId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('createTicketTerm', 'smartTransferCreateTicketTerm', smartTransferCreateTicketTerm);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('createTicketTerm', 'ticketId', ticketId);
                    localVarPath = "/smart-transfers/{ticketId}/terms"
                        .replace("{".concat("ticketId", "}"), encodeURIComponent(String(ticketId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(smartTransferCreateTicketTerm, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Find Smart Transfer ticket by id
         * @summary Search Tickets by ID
         * @param {string} ticketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTicketById: function (ticketId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('findTicketById', 'ticketId', ticketId);
                    localVarPath = "/smart-transfers/{ticketId}"
                        .replace("{".concat("ticketId", "}"), encodeURIComponent(String(ticketId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Find Smart Transfer ticket term by id
         * @summary Search ticket by leg (term) ID
         * @param {string} ticketId
         * @param {string} termId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTicketTermById: function (ticketId, termId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('findTicketTermById', 'ticketId', ticketId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('findTicketTermById', 'termId', termId);
                    localVarPath = "/smart-transfers/{ticketId}/terms/{termId}"
                        .replace("{".concat("ticketId", "}"), encodeURIComponent(String(ticketId)))
                        .replace("{".concat("termId", "}"), encodeURIComponent(String(termId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Manually fulfill ticket, in case when all terms (legs) are funded manually
         * @summary Fund ticket manually
         * @param {string} ticketId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fulfillTicket: function (ticketId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('fulfillTicket', 'ticketId', ticketId);
                    localVarPath = "/smart-transfers/{ticketId}/fulfill"
                        .replace("{".concat("ticketId", "}"), encodeURIComponent(String(ticketId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Create or fulfill dvp ticket order
         * @summary Fund dvp ticket
         * @param {SmartTransferFundDvpTicket} smartTransferFundDvpTicket
         * @param {string} ticketId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fundDvpTicket: function (smartTransferFundDvpTicket, ticketId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('fundDvpTicket', 'smartTransferFundDvpTicket', smartTransferFundDvpTicket);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('fundDvpTicket', 'ticketId', ticketId);
                    localVarPath = "/smart_transfers/{ticketId}/dvp/fund"
                        .replace("{".concat("ticketId", "}"), encodeURIComponent(String(ticketId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(smartTransferFundDvpTicket, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Set funding source for ticket term (in case of ASYNC tickets, this will execute transfer immediately)
         * @summary Define funding source
         * @param {SmartTransferFundTerm} smartTransferFundTerm
         * @param {string} ticketId
         * @param {string} termId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fundTicketTerm: function (smartTransferFundTerm, ticketId, termId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('fundTicketTerm', 'smartTransferFundTerm', smartTransferFundTerm);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('fundTicketTerm', 'ticketId', ticketId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('fundTicketTerm', 'termId', termId);
                    localVarPath = "/smart-transfers/{ticketId}/terms/{termId}/fund"
                        .replace("{".concat("ticketId", "}"), encodeURIComponent(String(ticketId)))
                        .replace("{".concat("termId", "}"), encodeURIComponent(String(termId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(smartTransferFundTerm, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get smart transfer statistic
         * @summary Get smart transfers statistic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSmartTransferStatistic: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/smart_transfers/statistic";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get Smart Transfer user groups
         * @summary Get user group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSmartTransferUserGroups: function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/smart-transfers/settings/user-groups";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Manually set ticket term transaction
         * @summary Manually add term transaction
         * @param {SmartTransferManuallyFundTerm} smartTransferManuallyFundTerm
         * @param {string} ticketId
         * @param {string} termId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manuallyFundTicketTerm: function (smartTransferManuallyFundTerm, ticketId, termId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('manuallyFundTicketTerm', 'smartTransferManuallyFundTerm', smartTransferManuallyFundTerm);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('manuallyFundTicketTerm', 'ticketId', ticketId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('manuallyFundTicketTerm', 'termId', termId);
                    localVarPath = "/smart-transfers/{ticketId}/terms/{termId}/manually-fund"
                        .replace("{".concat("ticketId", "}"), encodeURIComponent(String(ticketId)))
                        .replace("{".concat("termId", "}"), encodeURIComponent(String(termId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(smartTransferManuallyFundTerm, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Delete ticket term when ticket is in DRAFT status
         * @summary Delete ticket leg (term)
         * @param {string} ticketId
         * @param {string} termId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTicketTerm: function (ticketId, termId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('removeTicketTerm', 'ticketId', ticketId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('removeTicketTerm', 'termId', termId);
                    localVarPath = "/smart-transfers/{ticketId}/terms/{termId}"
                        .replace("{".concat("ticketId", "}"), encodeURIComponent(String(ticketId)))
                        .replace("{".concat("termId", "}"), encodeURIComponent(String(termId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Finds Smart Transfer tickets that match the submitted criteria
         * @summary Find Ticket
         * @param {string} [q] Search string - counterparty name or asset or ticketId. Optional
         * @param {Array<SearchTicketsStatusesEnum>} [statuses] Ticket statuses for Smart Transfer tickets. Optional
         * @param {string} [networkId] NetworkId that is used in the ticket . Optional
         * @param {boolean} [createdByMe] Filter created tickets by created by self or by others. Optional
         * @param {string} [expiresAfter] Lower bound of search range. Optional
         * @param {string} [expiresBefore] Upper bound of search range. Optional
         * @param {SearchTicketsTypeEnum} [type] Type of transfer. ASYNC executes transfers as they are funded, DVP executes all terms (legs) as one dvp transfer
         * @param {string} [externalRefId] External ref. ID that workspace can use to identify ticket outside of Fireblocks system.
         * @param {string} [after] ID of the record after which to fetch $limit records
         * @param {number} [limit] Number of records to fetch. By default, it is 100
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTickets: function (q, statuses, networkId, createdByMe, expiresAfter, expiresBefore, type, externalRefId, after, limit, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/smart-transfers";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (q !== undefined) {
                        localVarQueryParameter['q'] = q;
                    }
                    if (statuses) {
                        localVarQueryParameter['statuses'] = statuses;
                    }
                    if (networkId !== undefined) {
                        localVarQueryParameter['networkId'] = networkId;
                    }
                    if (createdByMe !== undefined) {
                        localVarQueryParameter['createdByMe'] = createdByMe;
                    }
                    if (expiresAfter !== undefined) {
                        localVarQueryParameter['expiresAfter'] = (expiresAfter instanceof Date) ?
                            expiresAfter.toISOString() :
                            expiresAfter;
                    }
                    if (expiresBefore !== undefined) {
                        localVarQueryParameter['expiresBefore'] = (expiresBefore instanceof Date) ?
                            expiresBefore.toISOString() :
                            expiresBefore;
                    }
                    if (type !== undefined) {
                        localVarQueryParameter['type'] = type;
                    }
                    if (externalRefId !== undefined) {
                        localVarQueryParameter['externalRefId'] = externalRefId;
                    }
                    if (after !== undefined) {
                        localVarQueryParameter['after'] = after;
                    }
                    if (limit !== undefined) {
                        localVarQueryParameter['limit'] = limit;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Set external id Smart Transfer ticket
         * @summary Add external ref. ID
         * @param {SmartTransferSetTicketExternalId} smartTransferSetTicketExternalId
         * @param {string} ticketId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalRefId: function (smartTransferSetTicketExternalId, ticketId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('setExternalRefId', 'smartTransferSetTicketExternalId', smartTransferSetTicketExternalId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('setExternalRefId', 'ticketId', ticketId);
                    localVarPath = "/smart-transfers/{ticketId}/external-id"
                        .replace("{".concat("ticketId", "}"), encodeURIComponent(String(ticketId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(smartTransferSetTicketExternalId, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Set expiration date on Smart Transfer ticket
         * @summary Set expiration
         * @param {SmartTransferSetTicketExpiration} smartTransferSetTicketExpiration
         * @param {string} ticketId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTicketExpiration: function (smartTransferSetTicketExpiration, ticketId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('setTicketExpiration', 'smartTransferSetTicketExpiration', smartTransferSetTicketExpiration);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('setTicketExpiration', 'ticketId', ticketId);
                    localVarPath = "/smart-transfers/{ticketId}/expires-in"
                        .replace("{".concat("ticketId", "}"), encodeURIComponent(String(ticketId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(smartTransferSetTicketExpiration, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Set Smart Transfer user group
         * @summary Set user group
         * @param {SmartTransferSetUserGroups} smartTransferSetUserGroups
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserGroups: function (smartTransferSetUserGroups, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('setUserGroups', 'smartTransferSetUserGroups', smartTransferSetUserGroups);
                    localVarPath = "/smart-transfers/settings/user-groups";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(smartTransferSetUserGroups, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Submit Smart Transfer ticket - change status into ready for approval if auto approval is not turned on, or OPEN if auto approval is on
         * @summary Submit ticket
         * @param {SmartTransferSubmitTicket} smartTransferSubmitTicket
         * @param {string} ticketId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTicket: function (smartTransferSubmitTicket, ticketId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('submitTicket', 'smartTransferSubmitTicket', smartTransferSubmitTicket);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('submitTicket', 'ticketId', ticketId);
                    localVarPath = "/smart-transfers/{ticketId}/submit"
                        .replace("{".concat("ticketId", "}"), encodeURIComponent(String(ticketId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(smartTransferSubmitTicket, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Update ticket term (when ticket status is DRAFT)
         * @summary Update ticket leg (term)
         * @param {SmartTransferUpdateTicketTerm} smartTransferUpdateTicketTerm
         * @param {string} ticketId
         * @param {string} termId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicketTerm: function (smartTransferUpdateTicketTerm, ticketId, termId, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('updateTicketTerm', 'smartTransferUpdateTicketTerm', smartTransferUpdateTicketTerm);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('updateTicketTerm', 'ticketId', ticketId);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('updateTicketTerm', 'termId', termId);
                    localVarPath = "/smart-transfers/{ticketId}/terms/{termId}"
                        .replace("{".concat("ticketId", "}"), encodeURIComponent(String(ticketId)))
                        .replace("{".concat("termId", "}"), encodeURIComponent(String(termId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'PUT' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(smartTransferUpdateTicketTerm, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.SmartTransferApiAxiosParamCreator = SmartTransferApiAxiosParamCreator;
/**
 * SmartTransferApi - functional programming interface
 * @export
 */
var SmartTransferApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.SmartTransferApiAxiosParamCreator)(configuration);
    return {
        /**
         * Set funding source for ticket term and creating approving transaction for contract to transfer asset
         * @summary Define funding source and give approve to contract to transfer asset
         * @param {SmartTransferApproveTerm} smartTransferApproveTerm
         * @param {string} ticketId
         * @param {string} termId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveDvPTicketTerm: function (smartTransferApproveTerm, ticketId, termId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.approveDvPTicketTerm(smartTransferApproveTerm, ticketId, termId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.approveDvPTicketTerm']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Cancel Smart Transfer ticket
         * @summary Cancel Ticket
         * @param {string} ticketId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTicket: function (ticketId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.cancelTicket(ticketId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.cancelTicket']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Creates new Smart Transfer ticket
         * @summary Create Ticket
         * @param {SmartTransferCreateTicket} smartTransferCreateTicket
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket: function (smartTransferCreateTicket, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createTicket(smartTransferCreateTicket, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.createTicket']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Creates new smart transfer ticket term (when the ticket status is DRAFT)
         * @summary Create leg (term)
         * @param {SmartTransferCreateTicketTerm} smartTransferCreateTicketTerm
         * @param {string} ticketId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketTerm: function (smartTransferCreateTicketTerm, ticketId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createTicketTerm(smartTransferCreateTicketTerm, ticketId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.createTicketTerm']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Find Smart Transfer ticket by id
         * @summary Search Tickets by ID
         * @param {string} ticketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTicketById: function (ticketId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.findTicketById(ticketId, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.findTicketById']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Find Smart Transfer ticket term by id
         * @summary Search ticket by leg (term) ID
         * @param {string} ticketId
         * @param {string} termId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTicketTermById: function (ticketId, termId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.findTicketTermById(ticketId, termId, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.findTicketTermById']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Manually fulfill ticket, in case when all terms (legs) are funded manually
         * @summary Fund ticket manually
         * @param {string} ticketId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fulfillTicket: function (ticketId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.fulfillTicket(ticketId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.fulfillTicket']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Create or fulfill dvp ticket order
         * @summary Fund dvp ticket
         * @param {SmartTransferFundDvpTicket} smartTransferFundDvpTicket
         * @param {string} ticketId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fundDvpTicket: function (smartTransferFundDvpTicket, ticketId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.fundDvpTicket(smartTransferFundDvpTicket, ticketId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.fundDvpTicket']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Set funding source for ticket term (in case of ASYNC tickets, this will execute transfer immediately)
         * @summary Define funding source
         * @param {SmartTransferFundTerm} smartTransferFundTerm
         * @param {string} ticketId
         * @param {string} termId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fundTicketTerm: function (smartTransferFundTerm, ticketId, termId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.fundTicketTerm(smartTransferFundTerm, ticketId, termId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.fundTicketTerm']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Get smart transfer statistic
         * @summary Get smart transfers statistic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSmartTransferStatistic: function (options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSmartTransferStatistic(options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.getSmartTransferStatistic']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Get Smart Transfer user groups
         * @summary Get user group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSmartTransferUserGroups: function (options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getSmartTransferUserGroups(options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.getSmartTransferUserGroups']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Manually set ticket term transaction
         * @summary Manually add term transaction
         * @param {SmartTransferManuallyFundTerm} smartTransferManuallyFundTerm
         * @param {string} ticketId
         * @param {string} termId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manuallyFundTicketTerm: function (smartTransferManuallyFundTerm, ticketId, termId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.manuallyFundTicketTerm(smartTransferManuallyFundTerm, ticketId, termId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.manuallyFundTicketTerm']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Delete ticket term when ticket is in DRAFT status
         * @summary Delete ticket leg (term)
         * @param {string} ticketId
         * @param {string} termId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTicketTerm: function (ticketId, termId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.removeTicketTerm(ticketId, termId, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.removeTicketTerm']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Finds Smart Transfer tickets that match the submitted criteria
         * @summary Find Ticket
         * @param {string} [q] Search string - counterparty name or asset or ticketId. Optional
         * @param {Array<SearchTicketsStatusesEnum>} [statuses] Ticket statuses for Smart Transfer tickets. Optional
         * @param {string} [networkId] NetworkId that is used in the ticket . Optional
         * @param {boolean} [createdByMe] Filter created tickets by created by self or by others. Optional
         * @param {string} [expiresAfter] Lower bound of search range. Optional
         * @param {string} [expiresBefore] Upper bound of search range. Optional
         * @param {SearchTicketsTypeEnum} [type] Type of transfer. ASYNC executes transfers as they are funded, DVP executes all terms (legs) as one dvp transfer
         * @param {string} [externalRefId] External ref. ID that workspace can use to identify ticket outside of Fireblocks system.
         * @param {string} [after] ID of the record after which to fetch $limit records
         * @param {number} [limit] Number of records to fetch. By default, it is 100
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTickets: function (q, statuses, networkId, createdByMe, expiresAfter, expiresBefore, type, externalRefId, after, limit, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.searchTickets(q, statuses, networkId, createdByMe, expiresAfter, expiresBefore, type, externalRefId, after, limit, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.searchTickets']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Set external id Smart Transfer ticket
         * @summary Add external ref. ID
         * @param {SmartTransferSetTicketExternalId} smartTransferSetTicketExternalId
         * @param {string} ticketId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalRefId: function (smartTransferSetTicketExternalId, ticketId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setExternalRefId(smartTransferSetTicketExternalId, ticketId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.setExternalRefId']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Set expiration date on Smart Transfer ticket
         * @summary Set expiration
         * @param {SmartTransferSetTicketExpiration} smartTransferSetTicketExpiration
         * @param {string} ticketId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTicketExpiration: function (smartTransferSetTicketExpiration, ticketId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setTicketExpiration(smartTransferSetTicketExpiration, ticketId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.setTicketExpiration']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Set Smart Transfer user group
         * @summary Set user group
         * @param {SmartTransferSetUserGroups} smartTransferSetUserGroups
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserGroups: function (smartTransferSetUserGroups, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setUserGroups(smartTransferSetUserGroups, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.setUserGroups']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Submit Smart Transfer ticket - change status into ready for approval if auto approval is not turned on, or OPEN if auto approval is on
         * @summary Submit ticket
         * @param {SmartTransferSubmitTicket} smartTransferSubmitTicket
         * @param {string} ticketId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTicket: function (smartTransferSubmitTicket, ticketId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.submitTicket(smartTransferSubmitTicket, ticketId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.submitTicket']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Update ticket term (when ticket status is DRAFT)
         * @summary Update ticket leg (term)
         * @param {SmartTransferUpdateTicketTerm} smartTransferUpdateTicketTerm
         * @param {string} ticketId
         * @param {string} termId
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicketTerm: function (smartTransferUpdateTicketTerm, ticketId, termId, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.updateTicketTerm(smartTransferUpdateTicketTerm, ticketId, termId, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['SmartTransferApi.updateTicketTerm']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
    };
};
exports.SmartTransferApiFp = SmartTransferApiFp;
/**
 * SmartTransferApi - factory interface
 * @export
 */
var SmartTransferApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.SmartTransferApiFp)(configuration);
    return {
        /**
         * Set funding source for ticket term and creating approving transaction for contract to transfer asset
         * @summary Define funding source and give approve to contract to transfer asset
         * @param {SmartTransferApiApproveDvPTicketTermRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveDvPTicketTerm: function (requestParameters, options) {
            return localVarFp.approveDvPTicketTerm(requestParameters.smartTransferApproveTerm, requestParameters.ticketId, requestParameters.termId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Cancel Smart Transfer ticket
         * @summary Cancel Ticket
         * @param {SmartTransferApiCancelTicketRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTicket: function (requestParameters, options) {
            return localVarFp.cancelTicket(requestParameters.ticketId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Creates new Smart Transfer ticket
         * @summary Create Ticket
         * @param {SmartTransferApiCreateTicketRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket: function (requestParameters, options) {
            return localVarFp.createTicket(requestParameters.smartTransferCreateTicket, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Creates new smart transfer ticket term (when the ticket status is DRAFT)
         * @summary Create leg (term)
         * @param {SmartTransferApiCreateTicketTermRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketTerm: function (requestParameters, options) {
            return localVarFp.createTicketTerm(requestParameters.smartTransferCreateTicketTerm, requestParameters.ticketId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Find Smart Transfer ticket by id
         * @summary Search Tickets by ID
         * @param {SmartTransferApiFindTicketByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTicketById: function (requestParameters, options) {
            return localVarFp.findTicketById(requestParameters.ticketId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Find Smart Transfer ticket term by id
         * @summary Search ticket by leg (term) ID
         * @param {SmartTransferApiFindTicketTermByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTicketTermById: function (requestParameters, options) {
            return localVarFp.findTicketTermById(requestParameters.ticketId, requestParameters.termId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Manually fulfill ticket, in case when all terms (legs) are funded manually
         * @summary Fund ticket manually
         * @param {SmartTransferApiFulfillTicketRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fulfillTicket: function (requestParameters, options) {
            return localVarFp.fulfillTicket(requestParameters.ticketId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Create or fulfill dvp ticket order
         * @summary Fund dvp ticket
         * @param {SmartTransferApiFundDvpTicketRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fundDvpTicket: function (requestParameters, options) {
            return localVarFp.fundDvpTicket(requestParameters.smartTransferFundDvpTicket, requestParameters.ticketId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Set funding source for ticket term (in case of ASYNC tickets, this will execute transfer immediately)
         * @summary Define funding source
         * @param {SmartTransferApiFundTicketTermRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fundTicketTerm: function (requestParameters, options) {
            return localVarFp.fundTicketTerm(requestParameters.smartTransferFundTerm, requestParameters.ticketId, requestParameters.termId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get smart transfer statistic
         * @summary Get smart transfers statistic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSmartTransferStatistic: function (options) {
            return localVarFp.getSmartTransferStatistic(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get Smart Transfer user groups
         * @summary Get user group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSmartTransferUserGroups: function (options) {
            return localVarFp.getSmartTransferUserGroups(options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Manually set ticket term transaction
         * @summary Manually add term transaction
         * @param {SmartTransferApiManuallyFundTicketTermRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manuallyFundTicketTerm: function (requestParameters, options) {
            return localVarFp.manuallyFundTicketTerm(requestParameters.smartTransferManuallyFundTerm, requestParameters.ticketId, requestParameters.termId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Delete ticket term when ticket is in DRAFT status
         * @summary Delete ticket leg (term)
         * @param {SmartTransferApiRemoveTicketTermRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTicketTerm: function (requestParameters, options) {
            return localVarFp.removeTicketTerm(requestParameters.ticketId, requestParameters.termId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Finds Smart Transfer tickets that match the submitted criteria
         * @summary Find Ticket
         * @param {SmartTransferApiSearchTicketsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTickets: function (requestParameters, options) {
            if (requestParameters === void 0) { requestParameters = {}; }
            return localVarFp.searchTickets(requestParameters.q, requestParameters.statuses, requestParameters.networkId, requestParameters.createdByMe, requestParameters.expiresAfter, requestParameters.expiresBefore, requestParameters.type, requestParameters.externalRefId, requestParameters.after, requestParameters.limit, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Set external id Smart Transfer ticket
         * @summary Add external ref. ID
         * @param {SmartTransferApiSetExternalRefIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalRefId: function (requestParameters, options) {
            return localVarFp.setExternalRefId(requestParameters.smartTransferSetTicketExternalId, requestParameters.ticketId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Set expiration date on Smart Transfer ticket
         * @summary Set expiration
         * @param {SmartTransferApiSetTicketExpirationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTicketExpiration: function (requestParameters, options) {
            return localVarFp.setTicketExpiration(requestParameters.smartTransferSetTicketExpiration, requestParameters.ticketId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Set Smart Transfer user group
         * @summary Set user group
         * @param {SmartTransferApiSetUserGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserGroups: function (requestParameters, options) {
            return localVarFp.setUserGroups(requestParameters.smartTransferSetUserGroups, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Submit Smart Transfer ticket - change status into ready for approval if auto approval is not turned on, or OPEN if auto approval is on
         * @summary Submit ticket
         * @param {SmartTransferApiSubmitTicketRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTicket: function (requestParameters, options) {
            return localVarFp.submitTicket(requestParameters.smartTransferSubmitTicket, requestParameters.ticketId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Update ticket term (when ticket status is DRAFT)
         * @summary Update ticket leg (term)
         * @param {SmartTransferApiUpdateTicketTermRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicketTerm: function (requestParameters, options) {
            return localVarFp.updateTicketTerm(requestParameters.smartTransferUpdateTicketTerm, requestParameters.ticketId, requestParameters.termId, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.SmartTransferApiFactory = SmartTransferApiFactory;
/**
 * SmartTransferApi - object-oriented interface
 * @export
 * @class SmartTransferApi
 * @extends {BaseAPI}
 */
var SmartTransferApi = /** @class */ (function (_super) {
    __extends(SmartTransferApi, _super);
    function SmartTransferApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Set funding source for ticket term and creating approving transaction for contract to transfer asset
     * @summary Define funding source and give approve to contract to transfer asset
     * @param {SmartTransferApiApproveDvPTicketTermRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.approveDvPTicketTerm = function (requestParameters) {
        var _this = this;
        return (0, exports.SmartTransferApiFp)(this.configuration).approveDvPTicketTerm(requestParameters.smartTransferApproveTerm, requestParameters.ticketId, requestParameters.termId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Cancel Smart Transfer ticket
     * @summary Cancel Ticket
     * @param {SmartTransferApiCancelTicketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.cancelTicket = function (requestParameters) {
        var _this = this;
        return (0, exports.SmartTransferApiFp)(this.configuration).cancelTicket(requestParameters.ticketId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Creates new Smart Transfer ticket
     * @summary Create Ticket
     * @param {SmartTransferApiCreateTicketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.createTicket = function (requestParameters) {
        var _this = this;
        return (0, exports.SmartTransferApiFp)(this.configuration).createTicket(requestParameters.smartTransferCreateTicket, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Creates new smart transfer ticket term (when the ticket status is DRAFT)
     * @summary Create leg (term)
     * @param {SmartTransferApiCreateTicketTermRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.createTicketTerm = function (requestParameters) {
        var _this = this;
        return (0, exports.SmartTransferApiFp)(this.configuration).createTicketTerm(requestParameters.smartTransferCreateTicketTerm, requestParameters.ticketId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Find Smart Transfer ticket by id
     * @summary Search Tickets by ID
     * @param {SmartTransferApiFindTicketByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.findTicketById = function (requestParameters) {
        var _this = this;
        return (0, exports.SmartTransferApiFp)(this.configuration).findTicketById(requestParameters.ticketId).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Find Smart Transfer ticket term by id
     * @summary Search ticket by leg (term) ID
     * @param {SmartTransferApiFindTicketTermByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.findTicketTermById = function (requestParameters) {
        var _this = this;
        return (0, exports.SmartTransferApiFp)(this.configuration).findTicketTermById(requestParameters.ticketId, requestParameters.termId).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Manually fulfill ticket, in case when all terms (legs) are funded manually
     * @summary Fund ticket manually
     * @param {SmartTransferApiFulfillTicketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.fulfillTicket = function (requestParameters) {
        var _this = this;
        return (0, exports.SmartTransferApiFp)(this.configuration).fulfillTicket(requestParameters.ticketId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Create or fulfill dvp ticket order
     * @summary Fund dvp ticket
     * @param {SmartTransferApiFundDvpTicketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.fundDvpTicket = function (requestParameters) {
        var _this = this;
        return (0, exports.SmartTransferApiFp)(this.configuration).fundDvpTicket(requestParameters.smartTransferFundDvpTicket, requestParameters.ticketId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Set funding source for ticket term (in case of ASYNC tickets, this will execute transfer immediately)
     * @summary Define funding source
     * @param {SmartTransferApiFundTicketTermRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.fundTicketTerm = function (requestParameters) {
        var _this = this;
        return (0, exports.SmartTransferApiFp)(this.configuration).fundTicketTerm(requestParameters.smartTransferFundTerm, requestParameters.ticketId, requestParameters.termId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Get smart transfer statistic
     * @summary Get smart transfers statistic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.getSmartTransferStatistic = function () {
        var _this = this;
        return (0, exports.SmartTransferApiFp)(this.configuration).getSmartTransferStatistic().then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Get Smart Transfer user groups
     * @summary Get user group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.getSmartTransferUserGroups = function () {
        var _this = this;
        return (0, exports.SmartTransferApiFp)(this.configuration).getSmartTransferUserGroups().then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Manually set ticket term transaction
     * @summary Manually add term transaction
     * @param {SmartTransferApiManuallyFundTicketTermRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.manuallyFundTicketTerm = function (requestParameters) {
        var _this = this;
        return (0, exports.SmartTransferApiFp)(this.configuration).manuallyFundTicketTerm(requestParameters.smartTransferManuallyFundTerm, requestParameters.ticketId, requestParameters.termId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Delete ticket term when ticket is in DRAFT status
     * @summary Delete ticket leg (term)
     * @param {SmartTransferApiRemoveTicketTermRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.removeTicketTerm = function (requestParameters) {
        var _this = this;
        return (0, exports.SmartTransferApiFp)(this.configuration).removeTicketTerm(requestParameters.ticketId, requestParameters.termId).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Finds Smart Transfer tickets that match the submitted criteria
     * @summary Find Ticket
     * @param {SmartTransferApiSearchTicketsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.searchTickets = function (requestParameters) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.SmartTransferApiFp)(this.configuration).searchTickets(requestParameters.q, requestParameters.statuses, requestParameters.networkId, requestParameters.createdByMe, requestParameters.expiresAfter, requestParameters.expiresBefore, requestParameters.type, requestParameters.externalRefId, requestParameters.after, requestParameters.limit).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Set external id Smart Transfer ticket
     * @summary Add external ref. ID
     * @param {SmartTransferApiSetExternalRefIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.setExternalRefId = function (requestParameters) {
        var _this = this;
        return (0, exports.SmartTransferApiFp)(this.configuration).setExternalRefId(requestParameters.smartTransferSetTicketExternalId, requestParameters.ticketId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Set expiration date on Smart Transfer ticket
     * @summary Set expiration
     * @param {SmartTransferApiSetTicketExpirationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.setTicketExpiration = function (requestParameters) {
        var _this = this;
        return (0, exports.SmartTransferApiFp)(this.configuration).setTicketExpiration(requestParameters.smartTransferSetTicketExpiration, requestParameters.ticketId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Set Smart Transfer user group
     * @summary Set user group
     * @param {SmartTransferApiSetUserGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.setUserGroups = function (requestParameters) {
        var _this = this;
        return (0, exports.SmartTransferApiFp)(this.configuration).setUserGroups(requestParameters.smartTransferSetUserGroups, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Submit Smart Transfer ticket - change status into ready for approval if auto approval is not turned on, or OPEN if auto approval is on
     * @summary Submit ticket
     * @param {SmartTransferApiSubmitTicketRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.submitTicket = function (requestParameters) {
        var _this = this;
        return (0, exports.SmartTransferApiFp)(this.configuration).submitTicket(requestParameters.smartTransferSubmitTicket, requestParameters.ticketId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Update ticket term (when ticket status is DRAFT)
     * @summary Update ticket leg (term)
     * @param {SmartTransferApiUpdateTicketTermRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartTransferApi
     */
    SmartTransferApi.prototype.updateTicketTerm = function (requestParameters) {
        var _this = this;
        return (0, exports.SmartTransferApiFp)(this.configuration).updateTicketTerm(requestParameters.smartTransferUpdateTicketTerm, requestParameters.ticketId, requestParameters.termId, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    return SmartTransferApi;
}(base_1.BaseAPI));
exports.SmartTransferApi = SmartTransferApi;
/**
 * @export
 */
exports.SearchTicketsStatusesEnum = {
    Draft: 'DRAFT',
    PendingApproval: 'PENDING_APPROVAL',
    Open: 'OPEN',
    InSettlement: 'IN_SETTLEMENT',
    Fulfilled: 'FULFILLED',
    Expired: 'EXPIRED',
    Canceled: 'CANCELED'
};
/**
 * @export
 */
exports.SearchTicketsTypeEnum = {
    Async: 'ASYNC',
    Dvp: 'DVP'
};
//# sourceMappingURL=smart-transfer-api.js.map
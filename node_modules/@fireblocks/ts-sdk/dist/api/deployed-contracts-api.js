"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeployedContractsApi = exports.DeployedContractsApiFactory = exports.DeployedContractsApiFp = exports.DeployedContractsApiAxiosParamCreator = void 0;
var axios_1 = __importDefault(require("axios"));
var fireblocksResponse_1 = require("../response/fireblocksResponse");
// URLSearchParams not necessarily used
// @ts-ignore
var url_1 = require("url");
// Some imports not used depending on template conditions
// @ts-ignore
var common_1 = require("../common");
var validation_utils_1 = require("../utils/validation_utils");
// @ts-ignore
var base_1 = require("../base");
/**
 * DeployedContractsApi - axios parameter creator
 * @export
 */
var DeployedContractsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Save contract ABI for the tenant
         * @summary Save contract ABI
         * @param {AddAbiRequestDto} addAbiRequestDto
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContractABI: function (addAbiRequestDto, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('addContractABI', 'addAbiRequestDto', addAbiRequestDto);
                    localVarPath = "/tokenization/contracts/abi";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(addAbiRequestDto, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Fetch the ABI. If not found fetch the ABI from the block explorer
         * @summary Fetch the contract ABI
         * @param {FetchAbiRequestDto} fetchAbiRequestDto
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchContractAbi: function (fetchAbiRequestDto, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('fetchContractAbi', 'fetchAbiRequestDto', fetchAbiRequestDto);
                    localVarPath = "/tokenization/contracts/fetch_abi";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(fetchAbiRequestDto, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Return deployed contract data by blockchain native asset id and contract address
         * @summary Return deployed contract data
         * @param {string} contractAddress The contract\&#39;s onchain address
         * @param {string} assetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedContractByAddress: function (contractAddress, assetId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getDeployedContractByAddress', 'contractAddress', contractAddress);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getDeployedContractByAddress', 'assetId', assetId);
                    localVarPath = "/tokenization/contracts/{assetId}/{contractAddress}"
                        .replace("{".concat("contractAddress", "}"), encodeURIComponent(String(contractAddress)))
                        .replace("{".concat("assetId", "}"), encodeURIComponent(String(assetId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Return deployed contract data by id
         * @summary Return deployed contract data by id
         * @param {string} id The deployed contract data identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedContractById: function (id, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getDeployedContractById', 'id', id);
                    localVarPath = "/tokenization/contracts/{id}"
                        .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Return a filtered lean representation of the deployed contracts data on all blockchains (paginated)
         * @summary List deployed contracts data
         * @param {string} [pageCursor] Page cursor to get the next page
         * @param {number} [pageSize] Number of items per page, requesting more then max will return max items
         * @param {string} [contractAddress] The contract\&#39;s onchain address
         * @param {string} [baseAssetId]
         * @param {string} [contractTemplateId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedContracts: function (pageCursor, pageSize, contractAddress, baseAssetId, contractTemplateId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    localVarPath = "/tokenization/contracts";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (pageCursor !== undefined) {
                        localVarQueryParameter['pageCursor'] = pageCursor;
                    }
                    if (pageSize !== undefined) {
                        localVarQueryParameter['pageSize'] = pageSize;
                    }
                    if (contractAddress !== undefined) {
                        localVarQueryParameter['contractAddress'] = contractAddress;
                    }
                    if (baseAssetId !== undefined) {
                        localVarQueryParameter['baseAssetId'] = baseAssetId;
                    }
                    if (contractTemplateId !== undefined) {
                        localVarQueryParameter['contractTemplateId'] = contractTemplateId;
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.DeployedContractsApiAxiosParamCreator = DeployedContractsApiAxiosParamCreator;
/**
 * DeployedContractsApi - functional programming interface
 * @export
 */
var DeployedContractsApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.DeployedContractsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Save contract ABI for the tenant
         * @summary Save contract ABI
         * @param {AddAbiRequestDto} addAbiRequestDto
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContractABI: function (addAbiRequestDto, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.addContractABI(addAbiRequestDto, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['DeployedContractsApi.addContractABI']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Fetch the ABI. If not found fetch the ABI from the block explorer
         * @summary Fetch the contract ABI
         * @param {FetchAbiRequestDto} fetchAbiRequestDto
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchContractAbi: function (fetchAbiRequestDto, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.fetchContractAbi(fetchAbiRequestDto, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['DeployedContractsApi.fetchContractAbi']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Return deployed contract data by blockchain native asset id and contract address
         * @summary Return deployed contract data
         * @param {string} contractAddress The contract\&#39;s onchain address
         * @param {string} assetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedContractByAddress: function (contractAddress, assetId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getDeployedContractByAddress(contractAddress, assetId, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['DeployedContractsApi.getDeployedContractByAddress']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Return deployed contract data by id
         * @summary Return deployed contract data by id
         * @param {string} id The deployed contract data identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedContractById: function (id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getDeployedContractById(id, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['DeployedContractsApi.getDeployedContractById']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Return a filtered lean representation of the deployed contracts data on all blockchains (paginated)
         * @summary List deployed contracts data
         * @param {string} [pageCursor] Page cursor to get the next page
         * @param {number} [pageSize] Number of items per page, requesting more then max will return max items
         * @param {string} [contractAddress] The contract\&#39;s onchain address
         * @param {string} [baseAssetId]
         * @param {string} [contractTemplateId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedContracts: function (pageCursor, pageSize, contractAddress, baseAssetId, contractTemplateId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getDeployedContracts(pageCursor, pageSize, contractAddress, baseAssetId, contractTemplateId, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['DeployedContractsApi.getDeployedContracts']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
    };
};
exports.DeployedContractsApiFp = DeployedContractsApiFp;
/**
 * DeployedContractsApi - factory interface
 * @export
 */
var DeployedContractsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.DeployedContractsApiFp)(configuration);
    return {
        /**
         * Save contract ABI for the tenant
         * @summary Save contract ABI
         * @param {DeployedContractsApiAddContractABIRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContractABI: function (requestParameters, options) {
            return localVarFp.addContractABI(requestParameters.addAbiRequestDto, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Fetch the ABI. If not found fetch the ABI from the block explorer
         * @summary Fetch the contract ABI
         * @param {DeployedContractsApiFetchContractAbiRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchContractAbi: function (requestParameters, options) {
            return localVarFp.fetchContractAbi(requestParameters.fetchAbiRequestDto, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Return deployed contract data by blockchain native asset id and contract address
         * @summary Return deployed contract data
         * @param {DeployedContractsApiGetDeployedContractByAddressRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedContractByAddress: function (requestParameters, options) {
            return localVarFp.getDeployedContractByAddress(requestParameters.contractAddress, requestParameters.assetId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Return deployed contract data by id
         * @summary Return deployed contract data by id
         * @param {DeployedContractsApiGetDeployedContractByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedContractById: function (requestParameters, options) {
            return localVarFp.getDeployedContractById(requestParameters.id, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Return a filtered lean representation of the deployed contracts data on all blockchains (paginated)
         * @summary List deployed contracts data
         * @param {DeployedContractsApiGetDeployedContractsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedContracts: function (requestParameters, options) {
            if (requestParameters === void 0) { requestParameters = {}; }
            return localVarFp.getDeployedContracts(requestParameters.pageCursor, requestParameters.pageSize, requestParameters.contractAddress, requestParameters.baseAssetId, requestParameters.contractTemplateId, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.DeployedContractsApiFactory = DeployedContractsApiFactory;
/**
 * DeployedContractsApi - object-oriented interface
 * @export
 * @class DeployedContractsApi
 * @extends {BaseAPI}
 */
var DeployedContractsApi = /** @class */ (function (_super) {
    __extends(DeployedContractsApi, _super);
    function DeployedContractsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Save contract ABI for the tenant
     * @summary Save contract ABI
     * @param {DeployedContractsApiAddContractABIRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeployedContractsApi
     */
    DeployedContractsApi.prototype.addContractABI = function (requestParameters) {
        var _this = this;
        return (0, exports.DeployedContractsApiFp)(this.configuration).addContractABI(requestParameters.addAbiRequestDto, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Fetch the ABI. If not found fetch the ABI from the block explorer
     * @summary Fetch the contract ABI
     * @param {DeployedContractsApiFetchContractAbiRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeployedContractsApi
     */
    DeployedContractsApi.prototype.fetchContractAbi = function (requestParameters) {
        var _this = this;
        return (0, exports.DeployedContractsApiFp)(this.configuration).fetchContractAbi(requestParameters.fetchAbiRequestDto, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Return deployed contract data by blockchain native asset id and contract address
     * @summary Return deployed contract data
     * @param {DeployedContractsApiGetDeployedContractByAddressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeployedContractsApi
     */
    DeployedContractsApi.prototype.getDeployedContractByAddress = function (requestParameters) {
        var _this = this;
        return (0, exports.DeployedContractsApiFp)(this.configuration).getDeployedContractByAddress(requestParameters.contractAddress, requestParameters.assetId).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Return deployed contract data by id
     * @summary Return deployed contract data by id
     * @param {DeployedContractsApiGetDeployedContractByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeployedContractsApi
     */
    DeployedContractsApi.prototype.getDeployedContractById = function (requestParameters) {
        var _this = this;
        return (0, exports.DeployedContractsApiFp)(this.configuration).getDeployedContractById(requestParameters.id).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Return a filtered lean representation of the deployed contracts data on all blockchains (paginated)
     * @summary List deployed contracts data
     * @param {DeployedContractsApiGetDeployedContractsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeployedContractsApi
     */
    DeployedContractsApi.prototype.getDeployedContracts = function (requestParameters) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.DeployedContractsApiFp)(this.configuration).getDeployedContracts(requestParameters.pageCursor, requestParameters.pageSize, requestParameters.contractAddress, requestParameters.baseAssetId, requestParameters.contractTemplateId).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    return DeployedContractsApi;
}(base_1.BaseAPI));
exports.DeployedContractsApi = DeployedContractsApi;
//# sourceMappingURL=deployed-contracts-api.js.map
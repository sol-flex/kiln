"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Fireblocks API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.6.2
 * Contact: support@fireblocks.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenizationApi = exports.TokenizationApiFactory = exports.TokenizationApiFp = exports.TokenizationApiAxiosParamCreator = void 0;
var axios_1 = __importDefault(require("axios"));
var fireblocksResponse_1 = require("../response/fireblocksResponse");
// URLSearchParams not necessarily used
// @ts-ignore
var url_1 = require("url");
// Some imports not used depending on template conditions
// @ts-ignore
var common_1 = require("../common");
var validation_utils_1 = require("../utils/validation_utils");
// @ts-ignore
var base_1 = require("../base");
/**
 * TokenizationApi - axios parameter creator
 * @export
 */
var TokenizationApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Burn tokens in a collection
         * @summary Burn tokens
         * @param {CollectionBurnRequestDto} collectionBurnRequestDto
         * @param {string} id The collection link id
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        burnCollectionToken: function (collectionBurnRequestDto, id, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('burnCollectionToken', 'collectionBurnRequestDto', collectionBurnRequestDto);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('burnCollectionToken', 'id', id);
                    localVarPath = "/tokenization/collections/{id}/tokens/burn"
                        .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(collectionBurnRequestDto, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Create a new collection and link it as a token
         * @summary Create a new collection
         * @param {CollectionDeployRequestDto} collectionDeployRequestDto
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewCollection: function (collectionDeployRequestDto, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('createNewCollection', 'collectionDeployRequestDto', collectionDeployRequestDto);
                    localVarPath = "/tokenization/collections";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(collectionDeployRequestDto, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get collection token details by id
         * @summary Get collection token details
         * @param {string} id The collection link id
         * @param {string} tokenId The tokenId as it appears on the blockchain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchCollectionTokenDetails: function (id, tokenId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('fetchCollectionTokenDetails', 'id', id);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('fetchCollectionTokenDetails', 'tokenId', tokenId);
                    localVarPath = "/tokenization/collections/{id}/tokens/{tokenId}"
                        .replace("{".concat("id", "}"), encodeURIComponent(String(id)))
                        .replace("{".concat("tokenId", "}"), encodeURIComponent(String(tokenId)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get a collection by id
         * @summary Get a collection by id
         * @param {string} id The token link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionById: function (id, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getCollectionById', 'id', id);
                    localVarPath = "/tokenization/collections/{id}"
                        .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Get collections (paginated)
         * @summary Get collections
         * @param {string} [pageCursor] Page cursor to get the next page, for example - \&quot;MjAyMy0xMi0xMyAyMDozNjowOC4zMDI&#x3D;:MTEwMA&#x3D;&#x3D;\&quot;
         * @param {number} [pageSize] Number of items per page (max 100), requesting more then 100 will return 100 items
         * @param {any} [status] A comma separated list of statuses to filter. Default is \&quot;COMPLETED\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedCollections: function (pageCursor, pageSize, status, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, _i, _a, _b, key, value, headersFromBaseOptions;
                return __generator(this, function (_c) {
                    localVarPath = "/tokenization/collections";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (pageCursor !== undefined) {
                        localVarQueryParameter['pageCursor'] = pageCursor;
                    }
                    if (pageSize !== undefined) {
                        localVarQueryParameter['pageSize'] = pageSize;
                    }
                    if (status !== undefined) {
                        for (_i = 0, _a = Object.entries(status); _i < _a.length; _i++) {
                            _b = _a[_i], key = _b[0], value = _b[1];
                            localVarQueryParameter[key] = value;
                        }
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Return a linked token, with its status and metadata.
         * @summary Return a linked token
         * @param {string} id The token link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedToken: function (id, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('getLinkedToken', 'id', id);
                    localVarPath = "/tokenization/tokens/{id}"
                        .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Return all linked tokens (paginated)
         * @summary List all linked tokens
         * @param {string} [pageCursor] Page cursor to get the next page
         * @param {number} [pageSize] Number of items per page, requesting more then max will return max items
         * @param {any} [status] A comma separated list of statuses to filter. Default is \&quot;COMPLETED\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedTokens: function (pageCursor, pageSize, status, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, _i, _a, _b, key, value, headersFromBaseOptions;
                return __generator(this, function (_c) {
                    localVarPath = "/tokenization/tokens";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'GET' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (pageCursor !== undefined) {
                        localVarQueryParameter['pageCursor'] = pageCursor;
                    }
                    if (pageSize !== undefined) {
                        localVarQueryParameter['pageSize'] = pageSize;
                    }
                    if (status !== undefined) {
                        for (_i = 0, _a = Object.entries(status); _i < _a.length; _i++) {
                            _b = _a[_i], key = _b[0], value = _b[1];
                            localVarQueryParameter[key] = value;
                        }
                    }
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Facilitates the creation of a new token, supporting both EVM-based and Stellar/Ripple platforms. For EVM, it deploys the corresponding contract template to the blockchain and links the token to the workspace. For Stellar/Ripple, it links a newly created token directly to the workspace without deploying a contract. Returns the token link with status \"PENDING\" until the token is deployed or \"SUCCESS\" if no deployment is needed.
         * @summary Issue a new token
         * @param {CreateTokenRequestDto} createTokenRequestDto
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueNewToken: function (createTokenRequestDto, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('issueNewToken', 'createTokenRequestDto', createTokenRequestDto);
                    localVarPath = "/tokenization/tokens";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createTokenRequestDto, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Link an a contract
         * @summary Link a contract
         * @param {TokenLinkRequestDto} tokenLinkRequestDto
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        link: function (tokenLinkRequestDto, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('link', 'tokenLinkRequestDto', tokenLinkRequestDto);
                    localVarPath = "/tokenization/tokens/link";
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(tokenLinkRequestDto, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Mint tokens and upload metadata
         * @summary Mint tokens
         * @param {CollectionMintRequestDto} collectionMintRequestDto
         * @param {string} id The collection link id
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintCollectionToken: function (collectionMintRequestDto, id, idempotencyKey, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, common_1.assertParamExists)('mintCollectionToken', 'collectionMintRequestDto', collectionMintRequestDto);
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('mintCollectionToken', 'id', id);
                    localVarPath = "/tokenization/collections/{id}/tokens/mint"
                        .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'POST' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    if (idempotencyKey != null) {
                        localVarHeaderParameter['Idempotency-Key'] = String(idempotencyKey);
                    }
                    localVarHeaderParameter['Content-Type'] = 'application/json';
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(collectionMintRequestDto, localVarRequestOptions, configuration);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Unlink a token. The token will be unlinked from the workspace. The token will not be deleted on chain nor the refId, only the link to the workspace will be removed.
         * @summary Unlink a token
         * @param {string} id The token link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlink: function (id, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('unlink', 'id', id);
                    localVarPath = "/tokenization/tokens/{id}"
                        .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Delete a collection link
         * @summary Delete a collection link
         * @param {string} id The token link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkCollection: function (id, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    (0, validation_utils_1.assertParamExistsAndNotEmpty)('unlinkCollection', 'id', id);
                    localVarPath = "/tokenization/collections/{id}"
                        .replace("{".concat("id", "}"), encodeURIComponent(String(id)));
                    localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: 'DELETE' }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: (0, common_1.toPathString)(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
exports.TokenizationApiAxiosParamCreator = TokenizationApiAxiosParamCreator;
/**
 * TokenizationApi - functional programming interface
 * @export
 */
var TokenizationApiFp = function (configuration) {
    var localVarAxiosParamCreator = (0, exports.TokenizationApiAxiosParamCreator)(configuration);
    return {
        /**
         * Burn tokens in a collection
         * @summary Burn tokens
         * @param {CollectionBurnRequestDto} collectionBurnRequestDto
         * @param {string} id The collection link id
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        burnCollectionToken: function (collectionBurnRequestDto, id, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.burnCollectionToken(collectionBurnRequestDto, id, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['TokenizationApi.burnCollectionToken']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Create a new collection and link it as a token
         * @summary Create a new collection
         * @param {CollectionDeployRequestDto} collectionDeployRequestDto
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewCollection: function (collectionDeployRequestDto, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.createNewCollection(collectionDeployRequestDto, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['TokenizationApi.createNewCollection']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Get collection token details by id
         * @summary Get collection token details
         * @param {string} id The collection link id
         * @param {string} tokenId The tokenId as it appears on the blockchain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchCollectionTokenDetails: function (id, tokenId, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.fetchCollectionTokenDetails(id, tokenId, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['TokenizationApi.fetchCollectionTokenDetails']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Get a collection by id
         * @summary Get a collection by id
         * @param {string} id The token link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionById: function (id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getCollectionById(id, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['TokenizationApi.getCollectionById']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Get collections (paginated)
         * @summary Get collections
         * @param {string} [pageCursor] Page cursor to get the next page, for example - \&quot;MjAyMy0xMi0xMyAyMDozNjowOC4zMDI&#x3D;:MTEwMA&#x3D;&#x3D;\&quot;
         * @param {number} [pageSize] Number of items per page (max 100), requesting more then 100 will return 100 items
         * @param {any} [status] A comma separated list of statuses to filter. Default is \&quot;COMPLETED\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedCollections: function (pageCursor, pageSize, status, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getLinkedCollections(pageCursor, pageSize, status, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['TokenizationApi.getLinkedCollections']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Return a linked token, with its status and metadata.
         * @summary Return a linked token
         * @param {string} id The token link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedToken: function (id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getLinkedToken(id, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['TokenizationApi.getLinkedToken']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Return all linked tokens (paginated)
         * @summary List all linked tokens
         * @param {string} [pageCursor] Page cursor to get the next page
         * @param {number} [pageSize] Number of items per page, requesting more then max will return max items
         * @param {any} [status] A comma separated list of statuses to filter. Default is \&quot;COMPLETED\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedTokens: function (pageCursor, pageSize, status, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getLinkedTokens(pageCursor, pageSize, status, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['TokenizationApi.getLinkedTokens']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Facilitates the creation of a new token, supporting both EVM-based and Stellar/Ripple platforms. For EVM, it deploys the corresponding contract template to the blockchain and links the token to the workspace. For Stellar/Ripple, it links a newly created token directly to the workspace without deploying a contract. Returns the token link with status \"PENDING\" until the token is deployed or \"SUCCESS\" if no deployment is needed.
         * @summary Issue a new token
         * @param {CreateTokenRequestDto} createTokenRequestDto
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueNewToken: function (createTokenRequestDto, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.issueNewToken(createTokenRequestDto, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['TokenizationApi.issueNewToken']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Link an a contract
         * @summary Link a contract
         * @param {TokenLinkRequestDto} tokenLinkRequestDto
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        link: function (tokenLinkRequestDto, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.link(tokenLinkRequestDto, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['TokenizationApi.link']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Mint tokens and upload metadata
         * @summary Mint tokens
         * @param {CollectionMintRequestDto} collectionMintRequestDto
         * @param {string} id The collection link id
         * @param {string} [idempotencyKey] A unique identifier for the request. If the request is sent multiple times with the same idempotency key, the server will return the same response as the first request. The idempotency key is valid for 24 hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintCollectionToken: function (collectionMintRequestDto, id, idempotencyKey, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.mintCollectionToken(collectionMintRequestDto, id, idempotencyKey, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['TokenizationApi.mintCollectionToken']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Unlink a token. The token will be unlinked from the workspace. The token will not be deleted on chain nor the refId, only the link to the workspace will be removed.
         * @summary Unlink a token
         * @param {string} id The token link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlink: function (id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unlink(id, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['TokenizationApi.unlink']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
        /**
         * Delete a collection link
         * @summary Delete a collection link
         * @param {string} id The token link id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkCollection: function (id, options) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs, index, operationBasePath;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.unlinkCollection(id, options)];
                        case 1:
                            localVarAxiosArgs = _d.sent();
                            index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                            operationBasePath = (_c = (_b = base_1.operationServerMap['TokenizationApi.unlinkCollection']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                            return [2 /*return*/, function (axios, basePath) { return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, operationBasePath || basePath); }];
                    }
                });
            });
        },
    };
};
exports.TokenizationApiFp = TokenizationApiFp;
/**
 * TokenizationApi - factory interface
 * @export
 */
var TokenizationApiFactory = function (configuration, basePath, axios) {
    var localVarFp = (0, exports.TokenizationApiFp)(configuration);
    return {
        /**
         * Burn tokens in a collection
         * @summary Burn tokens
         * @param {TokenizationApiBurnCollectionTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        burnCollectionToken: function (requestParameters, options) {
            return localVarFp.burnCollectionToken(requestParameters.collectionBurnRequestDto, requestParameters.id, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Create a new collection and link it as a token
         * @summary Create a new collection
         * @param {TokenizationApiCreateNewCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewCollection: function (requestParameters, options) {
            return localVarFp.createNewCollection(requestParameters.collectionDeployRequestDto, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get collection token details by id
         * @summary Get collection token details
         * @param {TokenizationApiFetchCollectionTokenDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchCollectionTokenDetails: function (requestParameters, options) {
            return localVarFp.fetchCollectionTokenDetails(requestParameters.id, requestParameters.tokenId, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get a collection by id
         * @summary Get a collection by id
         * @param {TokenizationApiGetCollectionByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionById: function (requestParameters, options) {
            return localVarFp.getCollectionById(requestParameters.id, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Get collections (paginated)
         * @summary Get collections
         * @param {TokenizationApiGetLinkedCollectionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedCollections: function (requestParameters, options) {
            if (requestParameters === void 0) { requestParameters = {}; }
            return localVarFp.getLinkedCollections(requestParameters.pageCursor, requestParameters.pageSize, requestParameters.status, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Return a linked token, with its status and metadata.
         * @summary Return a linked token
         * @param {TokenizationApiGetLinkedTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedToken: function (requestParameters, options) {
            return localVarFp.getLinkedToken(requestParameters.id, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Return all linked tokens (paginated)
         * @summary List all linked tokens
         * @param {TokenizationApiGetLinkedTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLinkedTokens: function (requestParameters, options) {
            if (requestParameters === void 0) { requestParameters = {}; }
            return localVarFp.getLinkedTokens(requestParameters.pageCursor, requestParameters.pageSize, requestParameters.status, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Facilitates the creation of a new token, supporting both EVM-based and Stellar/Ripple platforms. For EVM, it deploys the corresponding contract template to the blockchain and links the token to the workspace. For Stellar/Ripple, it links a newly created token directly to the workspace without deploying a contract. Returns the token link with status \"PENDING\" until the token is deployed or \"SUCCESS\" if no deployment is needed.
         * @summary Issue a new token
         * @param {TokenizationApiIssueNewTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueNewToken: function (requestParameters, options) {
            return localVarFp.issueNewToken(requestParameters.createTokenRequestDto, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Link an a contract
         * @summary Link a contract
         * @param {TokenizationApiLinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        link: function (requestParameters, options) {
            return localVarFp.link(requestParameters.tokenLinkRequestDto, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Mint tokens and upload metadata
         * @summary Mint tokens
         * @param {TokenizationApiMintCollectionTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintCollectionToken: function (requestParameters, options) {
            return localVarFp.mintCollectionToken(requestParameters.collectionMintRequestDto, requestParameters.id, requestParameters.idempotencyKey, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Unlink a token. The token will be unlinked from the workspace. The token will not be deleted on chain nor the refId, only the link to the workspace will be removed.
         * @summary Unlink a token
         * @param {TokenizationApiUnlinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlink: function (requestParameters, options) {
            return localVarFp.unlink(requestParameters.id, options).then(function (request) { return request(axios, basePath); });
        },
        /**
         * Delete a collection link
         * @summary Delete a collection link
         * @param {TokenizationApiUnlinkCollectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkCollection: function (requestParameters, options) {
            return localVarFp.unlinkCollection(requestParameters.id, options).then(function (request) { return request(axios, basePath); });
        },
    };
};
exports.TokenizationApiFactory = TokenizationApiFactory;
/**
 * TokenizationApi - object-oriented interface
 * @export
 * @class TokenizationApi
 * @extends {BaseAPI}
 */
var TokenizationApi = /** @class */ (function (_super) {
    __extends(TokenizationApi, _super);
    function TokenizationApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Burn tokens in a collection
     * @summary Burn tokens
     * @param {TokenizationApiBurnCollectionTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenizationApi
     */
    TokenizationApi.prototype.burnCollectionToken = function (requestParameters) {
        var _this = this;
        return (0, exports.TokenizationApiFp)(this.configuration).burnCollectionToken(requestParameters.collectionBurnRequestDto, requestParameters.id, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Create a new collection and link it as a token
     * @summary Create a new collection
     * @param {TokenizationApiCreateNewCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenizationApi
     */
    TokenizationApi.prototype.createNewCollection = function (requestParameters) {
        var _this = this;
        return (0, exports.TokenizationApiFp)(this.configuration).createNewCollection(requestParameters.collectionDeployRequestDto, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Get collection token details by id
     * @summary Get collection token details
     * @param {TokenizationApiFetchCollectionTokenDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenizationApi
     */
    TokenizationApi.prototype.fetchCollectionTokenDetails = function (requestParameters) {
        var _this = this;
        return (0, exports.TokenizationApiFp)(this.configuration).fetchCollectionTokenDetails(requestParameters.id, requestParameters.tokenId).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Get a collection by id
     * @summary Get a collection by id
     * @param {TokenizationApiGetCollectionByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenizationApi
     */
    TokenizationApi.prototype.getCollectionById = function (requestParameters) {
        var _this = this;
        return (0, exports.TokenizationApiFp)(this.configuration).getCollectionById(requestParameters.id).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Get collections (paginated)
     * @summary Get collections
     * @param {TokenizationApiGetLinkedCollectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenizationApi
     */
    TokenizationApi.prototype.getLinkedCollections = function (requestParameters) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.TokenizationApiFp)(this.configuration).getLinkedCollections(requestParameters.pageCursor, requestParameters.pageSize, requestParameters.status).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Return a linked token, with its status and metadata.
     * @summary Return a linked token
     * @param {TokenizationApiGetLinkedTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenizationApi
     */
    TokenizationApi.prototype.getLinkedToken = function (requestParameters) {
        var _this = this;
        return (0, exports.TokenizationApiFp)(this.configuration).getLinkedToken(requestParameters.id).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Return all linked tokens (paginated)
     * @summary List all linked tokens
     * @param {TokenizationApiGetLinkedTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenizationApi
     */
    TokenizationApi.prototype.getLinkedTokens = function (requestParameters) {
        var _this = this;
        if (requestParameters === void 0) { requestParameters = {}; }
        return (0, exports.TokenizationApiFp)(this.configuration).getLinkedTokens(requestParameters.pageCursor, requestParameters.pageSize, requestParameters.status).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Facilitates the creation of a new token, supporting both EVM-based and Stellar/Ripple platforms. For EVM, it deploys the corresponding contract template to the blockchain and links the token to the workspace. For Stellar/Ripple, it links a newly created token directly to the workspace without deploying a contract. Returns the token link with status \"PENDING\" until the token is deployed or \"SUCCESS\" if no deployment is needed.
     * @summary Issue a new token
     * @param {TokenizationApiIssueNewTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenizationApi
     */
    TokenizationApi.prototype.issueNewToken = function (requestParameters) {
        var _this = this;
        return (0, exports.TokenizationApiFp)(this.configuration).issueNewToken(requestParameters.createTokenRequestDto, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Link an a contract
     * @summary Link a contract
     * @param {TokenizationApiLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenizationApi
     */
    TokenizationApi.prototype.link = function (requestParameters) {
        var _this = this;
        return (0, exports.TokenizationApiFp)(this.configuration).link(requestParameters.tokenLinkRequestDto, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Mint tokens and upload metadata
     * @summary Mint tokens
     * @param {TokenizationApiMintCollectionTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenizationApi
     */
    TokenizationApi.prototype.mintCollectionToken = function (requestParameters) {
        var _this = this;
        return (0, exports.TokenizationApiFp)(this.configuration).mintCollectionToken(requestParameters.collectionMintRequestDto, requestParameters.id, requestParameters.idempotencyKey).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Unlink a token. The token will be unlinked from the workspace. The token will not be deleted on chain nor the refId, only the link to the workspace will be removed.
     * @summary Unlink a token
     * @param {TokenizationApiUnlinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenizationApi
     */
    TokenizationApi.prototype.unlink = function (requestParameters) {
        var _this = this;
        return (0, exports.TokenizationApiFp)(this.configuration).unlink(requestParameters.id).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    /**
     * Delete a collection link
     * @summary Delete a collection link
     * @param {TokenizationApiUnlinkCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenizationApi
     */
    TokenizationApi.prototype.unlinkCollection = function (requestParameters) {
        var _this = this;
        return (0, exports.TokenizationApiFp)(this.configuration).unlinkCollection(requestParameters.id).then(function (request) { return request(_this.axios, _this.basePath); }).then(fireblocksResponse_1.convertToFireblocksResponse);
    };
    return TokenizationApi;
}(base_1.BaseAPI));
exports.TokenizationApi = TokenizationApi;
//# sourceMappingURL=tokenization-api.js.map
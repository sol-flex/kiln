"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FireblocksSigner = void 0;
const viem_1 = require("viem");
class FireblocksSigner {
    constructor(fireblocks, vaultId) {
        Object.defineProperty(this, "fireblocks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: fireblocks
        });
        Object.defineProperty(this, "vaultId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: vaultId
        });
    }
    async waitForTxCompletion(fbTx) {
        let tx = fbTx;
        while (tx.status !== 'COMPLETED') {
            const ERRORS = {
                BLOCKED: 'The transaction has been blocked by the TAP security policy.',
                FAILED: 'The transaction has failed.',
                CANCELLED: 'The transaction has been cancelled.',
                REJECTED: 'The transaction has been rejected, make sure that the TAP security policy is not blocking the transaction.',
            };
            if (tx.status && tx.status in ERRORS) {
                throw Error(ERRORS[tx.status]);
            }
            await new Promise((r) => setTimeout(r, 500));
            tx = (await this.fireblocks.transactions.getTransaction({ txId: fbTx.id })).data;
        }
        return tx;
    }
    async sign(payloadToSign, assetId, note = '') {
        const assetArgs = assetId
            ? {
                assetId,
                source: {
                    type: 'VAULT_ACCOUNT',
                    id: this.vaultId,
                },
            }
            : undefined;
        const tx = {
            ...assetArgs,
            operation: 'RAW',
            note,
            extraParameters: payloadToSign,
        };
        const fbTx = (await this.fireblocks.transactions.createTransaction({ transactionRequest: tx })).data;
        return await this.waitForTxCompletion(fbTx);
    }
    async signTypedMessage(eip712message, assetId, note = '') {
        const tx = {
            assetId: assetId,
            operation: 'TYPED_MESSAGE',
            source: {
                type: 'VAULT_ACCOUNT',
                id: this.vaultId,
            },
            note,
            extraParameters: {
                rawMessageData: {
                    messages: [
                        {
                            content: eip712message,
                            type: 'EIP712',
                        },
                    ],
                },
            },
        };
        const fbTx = (await this.fireblocks.transactions.createTransaction({ transactionRequest: tx })).data;
        return await this.waitForTxCompletion(fbTx);
    }
    async signAndBroadcastWith(payloadToSign, assetId, tx, destinationId, sendAmount = true, note = '') {
        const txArgs = {
            assetId: assetId,
            operation: 'CONTRACT_CALL',
            source: {
                type: 'VAULT_ACCOUNT',
                id: this.vaultId,
            },
            destination: {
                type: 'EXTERNAL_WALLET',
                id: destinationId,
            },
            amount: tx.amount_wei && sendAmount ? (0, viem_1.formatEther)(BigInt(tx.amount_wei), 'wei') : '0',
            note,
            extraParameters: payloadToSign,
            gasLimit: tx.gas_limit,
            priorityFee: (0, viem_1.formatUnits)(BigInt(tx.max_priority_fee_per_gas_wei), 9),
            maxFee: (0, viem_1.formatUnits)(BigInt(tx.max_fee_per_gas_wei), 9),
        };
        const fbTx = (await this.fireblocks.transactions.createTransaction({ transactionRequest: txArgs })).data;
        return await this.waitForTxCompletion(fbTx);
    }
}
exports.FireblocksSigner = FireblocksSigner;
//# sourceMappingURL=fireblocks_signer.js.map